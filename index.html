<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孤风</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="孤风">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="孤风">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孤风">
  
    <link rel="alternative" href="/atom.xml" title="孤风" type="application/atom+xml">
  
  
    <link rel="icon" href="/2.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="1.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">LoneWindFreedom</a></h1>
        </hgroup>
        
        <p class="header-subtitle">我愿意作一条逆流而上的鱼，即便喊不出声，也绝不让自己沉沦。</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/">主页</a></li>
                        
                            <li><a  href="/archives">管理</a></li>
                        
                            <li><a  href="/categories/随笔">随笔</a></li>
                        
                            <li><a  href="/categories/阅读">学习</a></li>
                        
                            <li><a  href="/categories/编程">编程</a></li>
                        
                            <li><a  href="/categories/书法">书法</a></li>
                        
                            <li><a  href="/categories/其它">其它</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail"  target="_blank" href="/" title="mail">mail</a>
                            
                                <a class="fl github"  target="_blank" href="https://github.com/LoneWindFreedom/LoneWindFreedom.github.io.git" title="github">github</a>
                            
                                <a class="fl zhihu"  target="_blank" href="/" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo"  target="_blank" href="/" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://ring3.xyz/">Yllen</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://mxny.org/">麦香浓郁</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://whereisk0shl.top/">K0sh1</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.ycjcl.cc/">信鑫</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://bystudent.com/">ByStundet表哥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.jarviswang.me/">汪神_Jarvis</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sh3ll.me/">Chu</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.hackfun.org/">4ido10n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/iamstudy">L3m0n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://o0xmuhe.me/">muhe</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.nuptzj.cn/">_画船听雨</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.virzz.com/index.html">Virink</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.sqlsec.com/">国光</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bodkin.ren/">老锥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cizel.cn/">C1zel</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://1phan.cc">1phan</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.liuil.top/">liuil</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/Ox9A82/">Ox9A82</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://burnegg.com/">burnegg</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://jwrsec.cn/">jwr-sec</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sudalover.cn/">苏打</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.binklac.com">VeroFess</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bendawang.site/">bendawang</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://weeklyalgo.codes/">hook</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.flier.net.cn/">Flier&#39;blog</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mutepig.club">mutepig</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.iret.xyz/list.aspx">Silver</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://simp1e.leanote.com/">Simple</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://processor.pub/">Processor</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一只淹死在二进制海洋里的二进制狗</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">LoneWindFreedom</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/1.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">LoneWindFreedom</a></h1>
            </hgroup>
            
            <p class="header-subtitle">我愿意作一条逆流而上的鱼，即便喊不出声，也绝不让自己沉沦。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives">管理</a></li>
                
                    <li><a href="/categories/随笔">随笔</a></li>
                
                    <li><a href="/categories/阅读">学习</a></li>
                
                    <li><a href="/categories/编程">编程</a></li>
                
                    <li><a href="/categories/书法">书法</a></li>
                
                    <li><a href="/categories/其它">其它</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="/" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/LoneWindFreedom/LoneWindFreedom.github.io.git" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="/" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="/" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-SpringBoot" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/27/SpringBoot/" class="article-date">
      <time datetime="2018-08-27T09:45:22.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/SpringBoot/">SpringBoot</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/content/SUMMARY.md</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/编程/">编程</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http与https的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/15/http与https的区别/" class="article-date">
      <time datetime="2018-08-15T01:25:38.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/http与https的区别/">http与https的区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>https就是http和TCP之间有一层SSL层，这一层的实际作用是防止钓鱼和加密。防止钓鱼通过网站的证书，网站必须有CA证书，证书类似于一个解密的签名。另外是加密，加密需要一个密钥交换算法，双方通过交换后的密钥加解密。<br>HTTPS和HTTP的区别：</p>
<pre><code>https协议需要到ca申请证书，一般免费证书很少，需要交费。

http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。

http和https使用的是完全不同的连接方式用的端口也不一样，前者是80，后者是443。

http的连接很简单，是无状态的。

HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。
</code></pre><p><a href="https://www.cnblogs.com/qiangxia/p/5261813.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiangxia/p/5261813.html</a></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/其它/">其它</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SQL注入" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/15/SQL注入/" class="article-date">
      <time datetime="2018-08-15T01:16:15.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/SQL注入/">sql注入</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>例如：<a href="http://cases/index.aspx?Id=100000054923742，进入这个页面，在数据库底层其实是做了一个select操作：select" target="_blank" rel="noopener">http://cases/index.aspx?Id=100000054923742，进入这个页面，在数据库底层其实是做了一个select操作：select</a> * from table_tmp where id =’100000054923742’（table_tmp和id是假设的表名和字段）</p>
<p>http://***/cases/index.aspx?Id=100000054923742’</p>
<p>http://***/cases/index.aspx?Id=100000054923742 and 1=1</p>
<p>http://***/cases/index.aspx?Id=100000054923742 and 1=2</p>
<p>如果执行①后，页面上提示报错或者提示数据库错误的话，说明是存在注入漏洞的。</p>
<p>如果执行②后，页面正常显示，而执行③后，页面报错，那么说明这个页面是存在注入漏洞的。</p>
<p>這里有个关键，就是如何判断是否真的报错，一般而言，现在的web开发如果报错了，不会直接将错误信息显示在页面上，有可能后台程序会做如下处理：如果出现错误跳转至特定页面。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/其它/">其它</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springMvc面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/13/springMvc面试题/" class="article-date">
      <time datetime="2018-08-13T08:36:26.000Z" itemprop="datePublished">2018-08-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/13/springMvc面试题/">SpringMvc</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>SpringMvc五层架构模式操作步骤：</p>
<p>1.web.xml文件中：第一：加载applicationContext.xml(加载spring容器)</p>
<blockquote>
<p>  第二：加载springMvc-servlet.xml(加载springMvc容器)</p>
</blockquote>
<blockquote>
<p>  &lt;?xml version=”1.0” encoding=”UTF-8”?></p>
</blockquote>
<blockquote>
<p>  &lt;web-app xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a></p>
</blockquote>
<blockquote>
<p>  xmlns=”<a href="http://java.sun.com/xml/ns/javaee&quot;" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee&quot;</a></p>
</blockquote>
<blockquote>
<p>  xsi:schemaLocation=”<a href="http://java.sun.com/xml/ns/javaee" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee</a><br>  <a href="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</a></p>
</blockquote>
<blockquote>
<p>  id=”WebApp_ID” version=”2.5”></p>
</blockquote>
<blockquote>
<p>  &lt;display-name>springmvcdemo\&lt;/display-name></p>
</blockquote>
<blockquote>
<p>  &lt;!– 加载applicationContext.xml文件 –></p>
</blockquote>
<blockquote>
<p>  &lt;context-param></p>
</blockquote>
<blockquote>
<p>  &lt;param-name>contextConfigLocation\&lt;/param-name></p>
</blockquote>
<blockquote>
<p>  &lt;param-value>classpath:applicationContext.xml\&lt;/param-value></p>
</blockquote>
<blockquote>
<p>  &lt;/context-param></p>
</blockquote>
<blockquote>
<p>  &lt;!– 加载监听器 –></p>
</blockquote>
<blockquote>
<p>  &lt;listener><br>  &lt;listener-class>org.springframework.web.context.ContextLoaderListener\&lt;/listener-class></p>
</blockquote>
<blockquote>
<p>  &lt;/listener></p>
</blockquote>
<blockquote>
<p>  &lt;servlet-mapping></p>
</blockquote>
<blockquote>
<p>  &lt;servlet-name>default\&lt;/servlet-name></p>
</blockquote>
<blockquote>
<p>  &lt;url-pattern>*.js\&lt;/url-pattern></p>
</blockquote>
<blockquote>
<p>  &lt;url-pattern>*.css\&lt;/url-pattern></p>
</blockquote>
<blockquote>
<p>  &lt;url-pattern>/assets/*\&quot;\&lt;/url-pattern></p>
</blockquote>
<blockquote>
<p>  &lt;url-pattern>/img1/*\&lt;/url-pattern></p>
</blockquote>
<blockquote>
<p>  &lt;/servlet-mapping></p>
</blockquote>
<blockquote>
<p>  &lt;servlet></p>
</blockquote>
<blockquote>
<p>  &lt;!– 加载springMvc-servlet.xml文件 –></p>
</blockquote>
<blockquote>
<p>  &lt;servlet-name>springMvc\&lt;/servlet-name></p>
</blockquote>
<blockquote>
<p>  &lt;!– 加载DispatcherServlet –></p>
</blockquote>
<blockquote>
<p>  &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet\&lt;/servlet-class></p>
</blockquote>
<blockquote>
<p>  &lt;load-on-startup>1\&lt;/load-on-startup></p>
</blockquote>
<blockquote>
<p>  &lt;/servlet></p>
</blockquote>
<blockquote>
<p>  &lt;servlet-mapping></p>
</blockquote>
<blockquote>
<p>  &lt;servlet-name>springMvc\&lt;/servlet-name></p>
</blockquote>
<blockquote>
<p>  &lt;url-pattern>/\&lt;/url-pattern></p>
</blockquote>
<blockquote>
<p>  &lt;/servlet-mapping></p>
</blockquote>
<blockquote>
<p>  &lt;!– 加载过滤器 –></p>
</blockquote>
<blockquote>
<p>  &lt;filter></p>
</blockquote>
<blockquote>
<p>  &lt;filter-name>characterEncodingfilter\&lt;/filter-name></p>
</blockquote>
<blockquote>
<p>  &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter\&lt;/filter-class></p>
</blockquote>
<blockquote>
<p>  &lt;init-param></p>
</blockquote>
<blockquote>
<p>  &lt;param-name>encoding\&lt;/param-name></p>
</blockquote>
<blockquote>
<p>  &lt;param-value>utf8\&lt;/param-value></p>
</blockquote>
<blockquote>
<p>  &lt;/init-param></p>
</blockquote>
<blockquote>
<p>  &lt;/filter></p>
</blockquote>
<blockquote>
<p>  &lt;filter-mapping></p>
</blockquote>
<blockquote>
<p>  &lt;filter-name>characterEncodingfilter\&lt;/filter-name></p>
</blockquote>
<blockquote>
<p>  &lt;url-pattern>*\&lt;/url-pattern></p>
</blockquote>
<blockquote>
<p>  &lt;/filter-mapping></p>
</blockquote>
<blockquote>
<p>  &lt;!– 设置默认页面 –></p>
</blockquote>
<blockquote>
<p>  &lt;welcome-file-list></p>
</blockquote>
<blockquote>
<p>  &lt;welcome-file>index.jsp\&lt;/welcome-file></p>
</blockquote>
<blockquote>
<p>  &lt;/welcome-file-list></p>
</blockquote>
<blockquote>
<p>  &lt;/web-app></p>
</blockquote>
<blockquote>
<p>  2.springMvc-servlet.xml文件：第一：扫描Controller控制类的包</p>
</blockquote>
<blockquote>
<p>  &lt;?xml version=”1.0” encoding=”UTF-8”?></p>
</blockquote>
<blockquote>
<p>  &lt;!–<br>  web控制的配置放在spring.xml中其他普通控制的配置放在application配置文件中<br>  –></p>
</blockquote>
<blockquote>
<p>  &lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans&quot;</a></p>
</blockquote>
<blockquote>
<p>  xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>  xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a></p>
</blockquote>
<blockquote>
<p>  xmlns:mvc=”<a href="http://www.springframework.org/schema/mvc&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/mvc&quot;</a></p>
</blockquote>
<blockquote>
<p>  xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/beans/spring-beans-4.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/context/spring-context-4.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/context/spring-context-4.0.xsd</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/mvc" target="_blank" rel="noopener">http://www.springframework.org/schema/mvc</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/mvc/spring-mvc.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/mvc/spring-mvc.xsd</a> “></p>
</blockquote>
<blockquote>
<p>  &lt;!–<br>  设置注解生效:因为hibernate-validator-5.4.2版本等级过高，不能使用资源文件功能<br>  &lt;mvc:annotation-driven</p>
</blockquote>
<blockquote>
<p>  validator=”validator” /> –></p>
</blockquote>
<blockquote>
<p>  &lt;!– 避免IE执行AJAX时,返回JSON出现下载文件，用来返回Map、List对象–></p>
</blockquote>
<blockquote>
<p>  &lt;bean<br>  class=”org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter”></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”messageConverters”></p>
</blockquote>
<blockquote>
<p>  &lt;ref bean=”mappingJacksonHttpMessageConverter” /></p>
</blockquote>
<blockquote>
<p>  &lt;/property></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;bean id=”mappingJacksonHttpMessageConverter”</p>
</blockquote>
<blockquote>
<p>  class=”org.springframework.http.converter.json.MappingJacksonHttpMessageConverter”></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”supportedMediaTypes”></p>
</blockquote>
<blockquote>
<p>  &lt;list></p>
</blockquote>
<blockquote>
<p>  &lt;value>text/html;charset=UTF-8\&lt;/value></p>
</blockquote>
<blockquote>
<p>  &lt;/list></p>
</blockquote>
<blockquote>
<p>  &lt;/property></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;!—加载注解驱动– ></p>
</blockquote>
<blockquote>
<p>  <a href="mvc:annotation-driven\" target="_blank" rel="noopener">mvc:annotation-driven\</a></p>
</blockquote>
<blockquote>
<p>  &lt;!– 修改HttpMessageConverter为utf-8 –></p>
</blockquote>
<blockquote>
<p>  &lt;mvc:message-converters register-defaults=”true”></p>
</blockquote>
<blockquote>
<p>  &lt;bean id=”fastJsonHttpMessageConverter”<br>  class=”com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter”></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”supportedMediaTypes”></p>
</blockquote>
<blockquote>
<p>  &lt;list></p>
</blockquote>
<blockquote>
<p>  &lt;!-当返回ajax请求时字符串编码格式为utf-8-></p>
</blockquote>
<blockquote>
<p>  &lt;value>application/json;charset=UTF-8\&lt;/value></p>
</blockquote>
<blockquote>
<p>  &lt;/list></p>
</blockquote>
<blockquote>
<p>  &lt;/property></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;/mvc:message-converters></p>
</blockquote>
<blockquote>
<p>  &lt;/mvc:annotation-driven></p>
</blockquote>
<blockquote>
<p>  &lt;!-加载映射器、适配器-></p>
</blockquote>
<blockquote>
<p>  &lt;mvc:default-servlet-handler /></p>
</blockquote>
<blockquote>
<p>  &lt;!– 加载要扫描的包 –></p>
</blockquote>
<blockquote>
<p>  &lt;context:component-scan base-package=”day0613,day0614” /></p>
</blockquote>
<blockquote>
<p>  &lt;bean id=”viewResolver”</p>
</blockquote>
<blockquote>
<p>  class=”org.springframework.web.servlet.view.UrlBasedViewResolver”></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”viewClass”</p>
</blockquote>
<blockquote>
<p>  value=”org.springframework.web.servlet.view.JstlView” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”prefix” value=”” />\&lt;!–前缀 –></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”suffix” value=”.jsp” />\&lt;!– 后缀 –></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;bean id=”multipartResolver”</p>
</blockquote>
<blockquote>
<p>  class=”org.springframework.web.multipart.commons.CommonsMultipartResolver”></p>
</blockquote>
<blockquote>
<p>  &lt;!– 上传文件大小上限，单位为字节（10MB） –></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”maxUploadSize”></p>
</blockquote>
<blockquote>
<p>  &lt;value>10485760\&lt;/value></p>
</blockquote>
<blockquote>
<p>  &lt;/property></p>
</blockquote>
<blockquote>
<p>  &lt;!– 请求的编码格式，必须和jSP的pageEncoding属性一致，<br>  以便正确读取表单的内容，默认为ISO-8859-1 –></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”defaultEncoding”></p>
</blockquote>
<blockquote>
<p>  &lt;value>UTF-8\&lt;/value></p>
</blockquote>
<blockquote>
<p>  &lt;/property></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;/beans></p>
</blockquote>
<blockquote>
<p>  3.applicationContext.xml文件：作用是配置MyBatis需要的驱动、用户名、密码等</p>
</blockquote>
<blockquote>
<p>  第一:加载jdbc.properties配置文件</p>
</blockquote>
<blockquote>
<p>  第二：扫描所有dao层包</p>
</blockquote>
<blockquote>
<p>  第三：扫描所有服务类的包</p>
</blockquote>
<blockquote>
<p>  第四：加载所有sql包下的sql执行语句的xml文件</p>
</blockquote>
<blockquote>
<p>  &lt;?xml version=”1.0” encoding=”UTF-8”?></p>
</blockquote>
<blockquote>
<p>  &lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans&quot;</a></p>
</blockquote>
<blockquote>
<p>  xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>  xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a></p>
</blockquote>
<blockquote>
<p>  xmlns:mvc=”<a href="http://www.springframework.org/schema/mvc&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/mvc&quot;</a></p>
</blockquote>
<blockquote>
<p>  xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/beans/spring-beans-4.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/context/spring-context-4.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/context/spring-context-4.0.xsd</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/mvc" target="_blank" rel="noopener">http://www.springframework.org/schema/mvc</a></p>
</blockquote>
<blockquote>
<p>  <a href="http://www.springframework.org/schema/mvc/spring-mvc.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/mvc/spring-mvc.xsd</a> “></p>
</blockquote>
<blockquote>
<p>  &lt;!– 加载配置文件jdbc.properties –></p>
</blockquote>
<blockquote>
<p>  &lt;context:property-placeholder location=”classpath:jdbc.properties” /></p>
</blockquote>
<blockquote>
<p>  &lt;!– ***************以下是dataSource 和<br>  Mybatis配置****************** –></p>
</blockquote>
<blockquote>
<p>  &lt;!– 1. dataSource 代替了mybatis的主配置文件中的xml的数据库连接配置 –></p>
</blockquote>
<blockquote>
<p>  &lt;bean id=”dataSource” class=”org.apache.commons.dbcp.BasicDataSource”</p>
</blockquote>
<blockquote>
<p>  destroy-method=”close”></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”driverClassName” value=”\${dataSource.driverClassName}” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”url” value=”\${dataSource.url}” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”username” value=”\${dataSource.username}” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”password” value=”\${dataSource.password}” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”initialSize” value=”\${dataSource.initialSize}” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”maxActive” value=”\${dataSource.maxActive}” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”maxIdle” value=”\${dataSource.maxIdle}” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”minIdle” value=”\${dataSource.minIdle}” /></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;!– 2. define the SqlSessionFactory<br>  代替了mybatis关于sqlSessionFactory的单例工厂 –></p>
</blockquote>
<blockquote>
<p>  &lt;bean id=”sqlSessionFactory”<br>  class=”org.mybatis.spring.SqlSessionFactoryBean”></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”dataSource” ref=”dataSource” /></p>
</blockquote>
<blockquote>
<p>  &lt;!– 3. 代替了mybatis主配置文件的需要搜寻的各个表的配置文件目录 –></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”mapperLocations”<br>  value=”classpath:sql/*.xml”>\&lt;/property></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;!–4.<br>  使用spring提供的mybatis工具类,DAO接口所在包名，Spring会自动查找其下的类 –></p>
</blockquote>
<blockquote>
<p>  &lt;bean class=”org.mybatis.spring.mapper.MapperScannerConfigurer”></p>
</blockquote>
<blockquote>
<p>  &lt;!– 4.1 指定了mapper的扫描包 –></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”basePackage” value=”day0614.dao” /></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”sqlSessionFactoryBeanName”<br>  value=”sqlSessionFactory”>\&lt;/property></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;!– 5. (事务管理)transaction manager, use JtaTransactionManager for global</p>
</blockquote>
<blockquote>
<p>  tx –></p>
</blockquote>
<blockquote>
<p>  &lt;bean id=”transactionManager”</p>
</blockquote>
<blockquote>
<p>  class=”org.springframework.jdbc.datasource.DataSourceTransactionManager”></p>
</blockquote>
<blockquote>
<p>  &lt;property name=”dataSource” ref=”dataSource” /></p>
</blockquote>
<blockquote>
<p>  &lt;/bean></p>
</blockquote>
<blockquote>
<p>  &lt;!– 扫描所有服务类的包 ，web容器是Controller容器的一个子类–></p>
</blockquote>
<blockquote>
<p>  &lt;context:component-scan base-package=”day0614.service” /></p>
</blockquote>
<blockquote>
<p>  &lt;/beans></p>
</blockquote>
<blockquote>
<p>  5.jdbc.properties文件：</p>
</blockquote>
<blockquote>
<p>  #DB</p>
</blockquote>
<blockquote>
<p>  dataSource.driverClassName=oracle.jdbc.driver.OracleDriver</p>
</blockquote>
<blockquote>
<p>  dataSource.url=jdbc:oracle:thin:\@localhost:1521:aaaa</p>
</blockquote>
<blockquote>
<p>  dataSource.username = oracleHomework</p>
</blockquote>
<blockquote>
<p>  dataSource.password = pf1234567</p>
</blockquote>
<blockquote>
<p>  dataSource.initialSize = 2</p>
</blockquote>
<blockquote>
<p>  dataSource.maxActive = 30</p>
</blockquote>
<blockquote>
<p>  dataSource.maxIdle = 5</p>
</blockquote>
<blockquote>
<p>  dataSource.minIdle = 5</p>
</blockquote>
<ol>
<li>在day0614包下创建一个springMvc控制类、一个实体类（成员变量为数据库中对应的字段名）。<br><img src="https://i.imgur.com/s36EvEu.png" alt=""></li>
<li>在day0614.dao，及day0614.service中：<br><img src="https://i.imgur.com/PFGGx9U.png" alt=""></li>
<li>spring框架中常用的注解及作用：</li>
</ol>
<blockquote>
<p>  @ModelAttribute：修饰方法、对象，由该注解修饰的方法，当其它任意方法被调用时该方法会在第一时间执行，类似于匿名内部类；注：当修饰对象时表示返回具体类的方法；</p>
</blockquote>
<blockquote>
<p>  @Controller：修饰类，表示该类为springMvc控制类；</p>
</blockquote>
<blockquote>
<p>  @RequestMapping(value=”/mm/{dd}”,params={dd<br>  =,…},method=RequestMethod.<em>Get</em>)：修饰方法或类，value表示该方法或类对象的路径或者与pathVarible绑定的参数，params表示要过滤的参数，如{dd=1}允许dd等于1的参数发送给后台，method表示该只允许指定的请求；produces表示返回的的数据编码格式如：”text/html;charset=UTF-8”、”application<br>  json;charset=UTF-8”</p>
</blockquote>
<blockquote>
<p>  @AutoWired：修饰变量或对象，表示由该注解修饰的变量会自动赋值，若为对象，则会自动创建对象；</p>
</blockquote>
<blockquote>
<p>  @Service：修饰类对象，表示该类为服务器控制类；</p>
</blockquote>
<blockquote>
<p>  @SessiAttribute(value={“keyNames”,…},type={ Integer.class<br>  ,Dounle.class,…})：修饰类对象，表示只允许访问符合SessionAttribute权限的方法；value表示允许Map中的key与keyNames相同的键值对或Model方法addAttribute(key,value)中的key相同的键值对发送给前端页面。注：Model与Map功能相同，model.addAttribute(key,value)\${key},map.put(key,value)\${RequestScope.key},\${SessionScope.key},\${Param.key}</p>
</blockquote>
<blockquote>
<p>  @RequestParam(value=”a2”,required=<strong>false</strong>) Date<br>  date：修饰变量，表示该变量名a2与jsp页面中的name属性值a2绑定,<br>  required表示该变量不是必须项，即jsp页面中没有该变量名或没有赋值，仍然允许请求；相当于request.getParameter(“”);</p>
</blockquote>
<blockquote>
<p>  @PathVarible：修饰变量，表示该变量名与RequestMapping中value中的{变量名}及jsp页面中name绑定的属性名；</p>
</blockquote>
<blockquote>
<p>  @DateFormat<br>  (pattern=”yyyy-MM-dd”)：修饰变量，通过该注解用来设置该日期变量的格式，表示该日期格式为yyyy-MM-dd格式；</p>
</blockquote>
<blockquote>
<p>  @InitBinder：修饰方法，表示该方法为验证方法，通过该方法可以设置数据格式如日期格式，数值格式等，可以注册并启用一个验证类对象；</p>
</blockquote>
<blockquote>
<p>  @Validated：修饰对象，通常与ModelAttribute同时使用表示启动该对象的验证注解；</p>
</blockquote>
<blockquote>
<p>  @ResponseBody：表示把该方法返回的字符串返回给json请求或ajax请求；</p>
</blockquote>
<ol>
<li>前端向后台发送数据</li>
</ol>
<blockquote>
<p>  Spring前端向后台发送数据的方法：get、post</p>
</blockquote>
<blockquote>
<p>  Spring后台接收前端发送的数据的方法：</p>
</blockquote>
<blockquote>
<p>  ①RequestParam注解修饰变量与前端页面中的name属性值绑定；</p>
</blockquote>
<blockquote>
<p>  ②PathVariable注解与\@RequestMapping中的{名称}绑定，而该名称会与jsp页面中的name属性值绑定；</p>
</blockquote>
<p>5.spring后台向前端页面传送数据：</p>
<blockquote>
<p>  ①HttpSession session—>session.setAttribute(<em>arg0</em>, <em>arg1</em>);</p>
</blockquote>
<blockquote>
<p>  ②Model modelmodel.addAttribute(<em>arg0</em>, <em>arg1);</em></p>
</blockquote>
<blockquote>
<p>  <em>注：Model的功能与Mapp相同,如果\@ModelAttribute(value=”attribute1”)value指定了attribute1，则map自动绑定Model中一个叫attribute1的对象中；如果没有绑定，则会放进Model中;且会跳转的路径为RequestMapping中的路径.jsp</em></p>
</blockquote>
<p><img src="https://i.imgur.com/jHyTEaY.png" alt=""></p>
<blockquote>
<p>  <em>③Map map—>map.put(key,value);</em></p>
</blockquote>
<blockquote>
<p>  <em>④HttpServletRequest requestrequest.setAttribute(String,object);</em></p>
</blockquote>
<blockquote>
<p>  <em>⑤ModelAndView modelView=new ModelAndView(“/jsp页面名称”, “对象描述”,<br>  对象);</em></p>
</blockquote>
<blockquote>
<p>  spring前端取后台传送的数据：</p>
</blockquote>
<blockquote>
<p>  ${Attribute名称}</p>
</blockquote>
<blockquote>
<p>  数据回显时：通过一下方式取得后台变量</p>
</blockquote>
<blockquote>
<p>  ${SessionScope.变量名}</p>
</blockquote>
<blockquote>
<p>  ${RequestScope.变量名}</p>
</blockquote>
<blockquote>
<p>  ${Param.变量名}</p>
</blockquote>
<blockquote>
<p>  后台取前端请求数据的方法：</p>
</blockquote>
<blockquote>
<p>  ①request.getParameter(“参数名称”);</p>
</blockquote>
<blockquote>
<p>  ②在后台相应的方法参数列表中使用\@RequestParam 参数对应的Java类型 参数名称</p>
</blockquote>
<p>6.spring中页面跳转的方法：</p>
<blockquote>
<p>  ① 返回ModelAndView</p>
</blockquote>
<blockquote>
<p>  <strong>public</strong> ModelAndView <strong>returnModelAndView</strong>(){</p>
</blockquote>
<blockquote>
<p>  //<br>  ModelAndView可以使用setViewName来设置要跳转的页面，同时可以用addObject来向页面传值</p>
</blockquote>
<blockquote>
<p>  System.<em>out</em>.println(“in returnModelAndView”+<strong>this</strong>);</p>
</blockquote>
<blockquote>
<p>  ModelAndView <strong>md</strong>=<strong>new</strong> ModelAndView();</p>
</blockquote>
<blockquote>
<p>  md.setViewName(“/success0605Return”);//跳转页面</p>
</blockquote>
<blockquote>
<p>  md.addObject(“msg0605ModelAndView”,”孤风”);//向jsp页面传送数据</p>
</blockquote>
<blockquote>
<p>  <strong>return</strong> md;</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<p>② 返回字符串</p>
<blockquote>
<p>  <strong>public</strong> String <strong>returnString</strong>(Model model){</p>
</blockquote>
<blockquote>
<p>  System.<em>out</em>.println(“in returnString”+<strong>this</strong>);</p>
</blockquote>
<blockquote>
<p>  model.addAttribute(“msg0605String”, “孤风2”);</p>
</blockquote>
<blockquote>
<p>  <strong>return</strong> “/success0605Return”;//页面跳转</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  ③ 使用HttpServletResponse response重定向</p>
</blockquote>
<blockquote>
<p>  <strong>public</strong> String <strong>returnNewNull</strong>(Model model,HttpServletResponse<br>  response) <strong>throws</strong> IOException{</p>
</blockquote>
<blockquote>
<p>  System.<em>out</em>.println(“in returnNewNull” +<strong>this</strong>);</p>
</blockquote>
<blockquote>
<p>  model.addAttribute(“msg0605returnNewNull”, “孤风3”);</p>
</blockquote>
<blockquote>
<p>  //使用response跳转，如果使用了sendRedirect则必须加后缀名.jsp,且要注意相对路径，Model失效；</p>
</blockquote>
<blockquote>
<p>  response.sendRedirect(“../success0605Return.jsp”);</p>
</blockquote>
<blockquote>
<p>  <strong>return null</strong>;</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  ④ HttpServletRequest request,HttpServletResponse response转发</p>
</blockquote>
<blockquote>
<p>  <strong>public void returnNewVoid</strong>(Model model,HttpServletRequest<br>  request,HttpServletResponse response) <strong>throws</strong> ServletException,<br>  IOException{</p>
</blockquote>
<blockquote>
<p>  System.<em>out</em>.println(“in returnNewVoid” +<strong>this</strong>);</p>
</blockquote>
<blockquote>
<p>  model.addAttribute(“msg0605returnNewVoid”, “孤风4”);</p>
</blockquote>
<blockquote>
<p>  RequestDispatcher<br>  <strong>rd</strong>=request.getRequestDispatcher(“../success0605Return.jsp”);</p>
</blockquote>
<blockquote>
<p>  rd.forward(request, response);//使用forward跳转页面</p>
</blockquote>
<blockquote>
<p>  <strong>return</strong> ;</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  ⑤使用spring提供的方法redirect:../+要跳转的jsp页面</p>
</blockquote>
<blockquote>
<p>  <strong>public</strong> String <strong>returnNewString</strong>(Model model){</p>
</blockquote>
<blockquote>
<p>  System.<em>out</em>.println(“in returnNewString”+<strong>this</strong>);</p>
</blockquote>
<blockquote>
<p>  model.addAttribute(“msg0605NewString”, “pf”);//传送失败</p>
</blockquote>
<blockquote>
<p>  //注：redirect:..关键字</p>
</blockquote>
<blockquote>
<p>  <strong>return</strong><br>  “redirect:../success0605Return.jsp”;//强制使用redirect跳转页面跳转（仍然使用了Spring）</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  ⑥使用spring提供的方法forward: ../+要跳转的jsp页面</p>
</blockquote>
<blockquote>
<p>  <strong>public</strong> String <strong>returnNewString2</strong>(Model model){</p>
</blockquote>
<blockquote>
<p>  System.<em>out</em>.println(“in returnNewString2”+<strong>this</strong>);</p>
</blockquote>
<blockquote>
<p>  model.addAttribute(“msg0605NewString2”, “pf2”);//可以传送成功</p>
</blockquote>
<blockquote>
<p>  String <strong>url</strong>=”../success0605Return.jsp”;</p>
</blockquote>
<blockquote>
<p>  //注：forward:..关键字</p>
</blockquote>
<blockquote>
<p>  <strong>return</strong> “forward:”+url;//强制使用forward跳转页面跳转（仍然使用了Spring）</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  注：页面跳转出现多路径问题的解决方法：在路径前加\${pageContext.request.contextPath}</p>
</blockquote>
<blockquote>
<p>  7.四大作用域及其提供的方法：</p>
</blockquote>
<blockquote>
<p>  ①Application：</p>
</blockquote>
<blockquote>
<p>  作用范围：整个应用程序；</p>
</blockquote>
<blockquote>
<p>  方法：Object getAttribute(String name);//表示从application中获取信息；</p>
</blockquote>
<blockquote>
<p>  Void setAttribute(String name,Object<br>  value);//向application作用域中设置信息；</p>
</blockquote>
<blockquote>
<p>  ②Session:</p>
</blockquote>
<blockquote>
<p>  作用范围：当前会话；</p>
</blockquote>
<blockquote>
<p>  方法：Object HttpSession.getAttribute(String<br>  name);//表示从Session作用域中取信息；</p>
</blockquote>
<blockquote>
<p>  Void HttpSession.setAttribute(String name,Object<br>  value);//向Session中设置信息；</p>
</blockquote>
<blockquote>
<p>  HttpSession HttpServletRequest.getSession(String<br>  name);//获取当前请求所在的session的对象。</p>
</blockquote>
<p>③Request：</p>
<p>作用范围：在当前请求中有效；</p>
<p>方法：Object getAttribute(String name);//从request作用域中取指定name的信息；</p>
<blockquote>
<p>  void setAttribute(String name,Object value);//向request作用域中设置信息；</p>
</blockquote>
<p>④Page：</p>
<blockquote>
<p>  作用范围：当前页面；</p>
</blockquote>
<p>方法：Object getAttribute(String name，int<br>Scope);//从page作用域中取指定name的信息；</p>
<blockquote>
<p>  void setAttribute(String name,Object value，int<br>  Scope);//向page作用域中设置信息；</p>
</blockquote>
<p>8.spring三种表单验证方式：</p>
<p>//绑定要验证的类：注：当使用\@InitBinder验证时，不能同时使用注解验证</p>
<p>\@InitBinder</p>
<p><strong>public void init</strong>(WebDataBinder binder){</p>
<p>System.<em>out</em>.println(“in initBinder”+<strong>this</strong>);</p>
<p>//给Spring的转换器指定一个日期转换类</p>
<p>SimpleDateFormat <strong>sdf</strong>=<strong>new</strong> SimpleDateFormat(“yyyy-MM-dd”);</p>
<p>binder.registerCustomEditor(Date.<strong>class</strong>,<strong>new</strong> CustomDateEditor(sdf,<br><strong>true</strong>));</p>
<p>//注册验证器，设置该对象对应的验证类</p>
<p>binder.setValidator(<strong>new</strong> MyValidated());//与验证类MyValidated关联</p>
<p>}</p>
<p>①Jsp验证：</p>
<p>//重点验证一JSP验证：</p>
<p>@RequestMapping(“/validated01”)</p>
<p><strong>public</strong> String <strong>validated</strong>(Model model,</p>
<p>@ModelAttribute(“msi”)\@Validated StudentInfo student,//启动注解</p>
<p>BindingResult result//注：必须直接写在Javabean StudentInfo student之后</p>
<p>){</p>
<p>System.<em>out</em>.println(“yes in init01”);</p>
<p>**</p>
<p>* result.hasErrors()方法获取的是\@InitBinder验证的错误信息；</p>
<p>* result.getFieldErrors()方法获取的是使用实体类中的注解验证的结果</p>
<p>*</p>
<p>* */</p>
<p><strong>if</strong>(result.hasErrors()){</p>
<p>//可以对result的错误信息做出一些处理，减少对form:form的依赖，适应未来的ajax和json格式请求</p>
<p>List&lt;FieldError> <strong>fe</strong>=result.getFieldErrors();//获取错误信息集合</p>
<p>Map&lt;String,String> <strong>msgError</strong>=<strong>new</strong> HashMap\&lt;String,String>();</p>
<p><strong>for</strong>(FieldError <strong>fe1</strong>:fe){</p>
<p>System.<em>out</em>.println(fe1);</p>
<p>System.<em>out</em>.println(fe1.getField()+”:”+fe1.getDefaultMessage());//遍历所有的错误信息</p>
<p>//如果msgError中不存在一个与当前key相同的错误信息，则执行添加</p>
<p><strong>if</strong>(msgError.get(fe1.getField())==<strong>null</strong>){</p>
<p>msgError.put(fe1.getField(),<br>fe1.getDefaultMessage());//将错误信息的getField和其对应的getDefaultMessage</p>
<p>}<strong>else</strong>{</p>
<p>String <strong>s</strong>=msgError.get(fe1.getField().toString());</p>
<p>msgError.put(fe1.getField(),<br>s+”,”+fe1.getDefaultMessage());//将错误信息的getField和其对应的getDefaultMessage</p>
<p>}</p>
<p>}</p>
<p>model.addAttribute(“msg”,msgError);</p>
<p><strong>return</strong><br>“/success0606Validated0”;//如果结果有错误信息，则返回指定页面（或原登录页面）</p>
<p>}</p>
<p><strong>return</strong> “/success0606Validated”;</p>
<p>}</p>
<p>②spring验证：</p>
<p>//验证二：Spring验证</p>
<p>@RequestMapping(“/validated03”)</p>
<p><strong>public</strong> String <strong>validated3</strong>(Model model){</p>
<p>StudentInfo <strong>studentInfo</strong>=<strong>new</strong> StudentInfo();</p>
<p>model.addAttribute(“msi”, studentInfo);</p>
<p><strong>return</strong> “/success0606Validated1”;</p>
<p>}</p>
<p>@RequestMapping(“/validated02”)</p>
<p><strong>public</strong> String <strong>validated2</strong>(Model model,</p>
<p>@ModelAttribute(“msi”) \@Validated StudentInfo student,//启动注解</p>
<p>BindingResult result//注：必须直接写在Javabean StudentInfo student之后</p>
<p>){</p>
<p>System.<em>out</em>.println(“yes in init02!”);</p>
<p><strong>if</strong>(result.hasErrors()){</p>
<p><strong>return</strong><br>“/success0606Validated1”;//如果结果有错误信息，则返回指定页面（或原登录页面）</p>
<p>}</p>
<p><strong>return</strong> “/success0606Validated”;</p>
<p>}</p>
<p>③注解验证：注：注解验证不需要\@InitBinder来注册和启动验证类</p>
<p>@RequestMapping(“/validated04”)</p>
<p><strong>public</strong> String <strong>validated</strong>(Model model,</p>
<p>@ModelAttribute(“msi”)\@Validated StudentInfo2 student,//启动注解</p>
<p>BindingResult result//注：必须直接写在Javabean StudentInfo student之后</p>
<p>){</p>
<p>System.<em>out</em>.println(“yes in init01”);</p>
<p><strong>if</strong>(result.hasErrors()){</p>
<p>//可以对result的错误信息做出一些处理</p>
<p>List&lt;FieldError> <strong>fe</strong>=result.getFieldErrors();//获取错误信息集合</p>
<p>Map&lt;String,String> <strong>msgError</strong>=<strong>new</strong> HashMap\&lt;String,String>();</p>
<p><strong>for</strong>(FieldError <strong>fe1</strong>:fe){</p>
<p>System.<em>out</em>.println(fe1);</p>
<p>System.<em>out</em>.println(fe1.getField()+”:”+fe1.getDefaultMessage());//遍历所有的错误信息</p>
<p>//如果msgError中不存在一个与当前key相同的错误信息，则执行添加</p>
<p><strong>if</strong>(msgError.get(fe1.getField())==<strong>null</strong>){</p>
<p>msgError.put(fe1.getField(),<br>fe1.getDefaultMessage());//将错误信息的getField和其对应的getDefaultMessage</p>
<p>}<strong>else</strong>{</p>
<p>String <strong>s</strong>=msgError.get(fe1.getField().toString());</p>
<p>msgError.put(fe1.getField(),<br>s+”,”+fe1.getDefaultMessage());//将错误信息的getField和其对应的getDefaultMessage</p>
<p>}</p>
<p>}</p>
<p>model.addAttribute(“msg”,msgError);</p>
<p><strong>return</strong><br>“/success0606Validated01”;//如果结果有错误信息，则返回指定页面（或原登录页面）</p>
<p>}</p>
<p><strong>return</strong> “/success0606Validated”;</p>
<p>}</p>
<p>三种验证方式的比较：</p>
<ol>
<li>spring验证：</li>
</ol>
<blockquote>
<p>  错误信息的显示：通过前端页面中form标签中modelAttribute=”msi”与\@ModelAttribute(“msi”)绑定，来实现错误信息的显示；再通过result.hasError()来判断是否为空，进而做出页面跳转；</p>
</blockquote>
<ol>
<li>jsp验证：</li>
</ol>
<blockquote>
<p>  通过判断result.hasError()是否为空，List\&lt;FieldError><br>  <strong>fe</strong>=result.getFieldErrors();//获取错误信息集合，遍历出该集合，取fe1.getField()和fe1.getDefaultMessage()再分别放进一个map集合中，把map与attribute绑定，前端页面通过el表达式获取相应的错误信息并显示；最后通过判断页面跳转；</p>
</blockquote>
<ol>
<li>注解验证：</li>
</ol>
<blockquote>
<p>  将所有判断的逻辑部分放在实体类中，使用注解做出相应的格式要求，List\&lt;FieldError><br>  <strong>fe</strong>=result.getFieldErrors();//获取错误信息集合，遍历出该集合，取fe1.getField()和fe1.getDefaultMessage()再分别放进一个map集合中，把map与attribute绑定，前端页面通过el表达式获取相应的错误信息并显示；最后通过判断页面跳转；</p>
</blockquote>
<blockquote>
<p>  springMvc的工作机制：</p>
</blockquote>
<ol>
<li><p>第一步：用户向服务器发送请求，请求被Spring前端控制Servelt<br>DispatcherServlet捕获；</p>
</li>
<li><p>第二步：<br>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URL），然后根据该URL调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p>
</li>
<li><p>第三步： DispatcherServlet<br>根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</p>
</li>
<li><p>第四步：提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。<br>在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： >></p>
<ol>
<li>HttpMessageConveter：<br>将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息<br>>> 2. 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等<br>>> 3. 数据根式化：对请求消息进行数据格式化。<br>如将字符串转换成格式化数字或格式化日期 >> 4. 数据验证：<br>验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ol>
</li>
<li><p>第五步： Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</p>
</li>
<li><p>第六步：根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet<br>；</p>
</li>
<li><p>第七步：ViewResolver 结合Model和View，来渲染视图</p>
</li>
<li><p>第八步：将渲染结果返回给客户端。</p>
</li>
</ol>
<p><img src="https://i.imgur.com/NXcNLfi.png" alt=""></p>
<p><strong>　　说明：</strong>前端控制器是接收web请求的入口，地位最重要。如果还要做其他具体的工作会使它的负担过于繁重，因此SpringMVC找来了四个帮手，叫做四个组件，来帮助前端控制器承担一些具体的工作，这样前端控制器就只发号司令做为集中控制调度中心，具体的工作交给四个组件来完成。</p>
<p>　　具体工作分为两部分：</p>
<ol>
<li>处理请求：两个组件，一个来找Handler，一个来执行Handler</li>
</ol>
<p>　　　　1)  处理器映射器负责找到URL对应的Handler对象</p>
<p>　　　　2)  处理器适配器负责执行找到的Handler对象。</p>
<p>　　 2.返回结果：两个组件，一个来找页面，一个来执行页面渲染</p>
<p>　　　　1)  视图解析器负责找到要返回的页面</p>
<p>　　　　2)  视图对象负责渲染页面，渲染页面需要的数据由前端控制器传给它。</p>
<h2 id="框架流程"><a href="#框架流程" class="headerlink" title="  框架流程"></a>  框架流程</h2><ol>
<li><p>用户发送请求至前端控制器DispatcherServlet</p>
</li>
<li><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
</li>
<li><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet</p>
</li>
<li><p>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p>
</li>
<li><p>执行处理器(handler也叫后端控制器–>Service–>DAO)</p>
</li>
<li><p>Handler执行完成返回ModelAndView</p>
</li>
<li><p>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</p>
</li>
<li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p>
</li>
<li><p>ViewReslover根据handler中设置的页面信息解析成一个View视图对象并返回它.</p>
</li>
<li><p>DispatcherServlet调用View对象的接口方法对实际的视图文件(如:<br>jsp文件)进行渲染（即将模型数据填充至视图文件中）</p>
</li>
<li><p>DispatcherServlet响应用户</p>
<p>需要认识的SpringMVC组件</p>
</li>
</ol>
<hr>
<p>　　SpringMVC的整个控制层采用组件式的结构。</p>
<p>　　SpringMVC的组件有：</p>
<p>　　　　前端控制器DispatcherServlet：负责接收用户请求，是整个流程的控制中心，但它几乎不做任何具体的工作，只进行任务调度。具体的工作由具体的组件来完成。这就是组件式结构的优势，专项事情又专门的组件来做，这样能提高专项的处理能力同时集中调度的存在降低了组件之间的耦合性。</p>
<p>　　　　处理器Handler（相对于前端控制器的后端控制器）：在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况<em>需要程序员根据业务需求开发Handler。</em></p>
<p>　　　　处理器映射器HandlerMapping：HandlerMapping负责为每个请求找到一个合适的处理器handler，其实简单来说就是维持了一个url到handler的映射Map。springmvc提供了不同的映射器，实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p>　　　　处理器适配器HandlerAdapter：处理器适配器HandlerAdapter负责执行具体的处理器。SpringMVC有多个适配器，当HandlerMapping找到了url对应的handler对象后，前端控制器会挑选一个能够执行这个handler的处理器适配器，然后给这个适配器发送指令，同时把这个handler对象传给这个适配器，让它执行handler，最终将handler的返回值和逻辑视图名字符串返回给前端控制器。</p>
<p>　　　　视图对象View：View对象负责渲染视图文件，将数据结果通过视图文件展示给用户。前端控制器调用View对象的接口方法render()，参数就是后台返回的数据，在render方法拿数据渲染视图文件生成返回给客户端的结果。</p>
<p>springmvc框架提供了很多的View类型，包括：jstlView、freemarkerView、pdfView等。</p>
<p>　　　　视图解析器ViewResolver：视图解析器（ViewResolver）负责解析出视图文件的物理路径，并根据这个路径生成视图View对象。ViewResolver首先把逻辑视图名解析成实际的页面位置，再生成视图View对象并返回给前端控制器。</p>
<p>其中HandlerMapping、HandlerAdapter、ViewResolver是springmvc的三大核心组件，Handler涉及具体业务需要程序员实现，View由ViewResolver生成，负责渲染页面。三大组件干的事情其实都可以集中交给DispatcherServlet来干，但都交给它会使它过于臃肿，处理效率会大大降低，因此分而治之才是上策。</p>
<p>所有使用\@RequestMapping修饰的方法都是一个handler对象</p>
<h3 id="组件总结"><a href="#组件总结" class="headerlink" title="组件总结"></a>组件总结</h3><p>　　SpringMVC的三大组件（理解记忆）：处理器映射器、处理器适配器、视图解析器</p>
<p>　　需要程序员编写代码的有：处理器（包括处理器、具体业务的service和dao）、视图文件（jsp）</p>
<p><strong>2.Spring框架中的三大核心思想是什么</strong></p>
<blockquote>
<p>  DI(依赖注入),IOC(控制反转),AOP(面向切面编程)</p>
</blockquote>
<blockquote>
<p>  DI：依赖是指把原本对象之间的联系和维护的权限交给spring容器来管理；注入是指property标签中的name（即取实体类对象中的属性）和value（给对应的属性赋值），相当于实体类中的get和set方法；</p>
</blockquote>
<blockquote>
<p>  IOC：与DI的概念相同，即把原本对象之间管理和维护的权限全部交给spring容器管理；在控制反转过程中使用了dom4J即Java反射机制；</p>
</blockquote>
<blockquote>
<p>  AOP：面向切面编程是相对于面向对象编程；后者在操作一个对象时，需要创建这个对象的实例，然后才能调用方法或者属性，是纵向的；而前者在使用时是使用了Java反射机制的，不需要创建对象就可以直接调用方法或属性；</p>
</blockquote>
<h3 id="使用Spring框架的好处是什么？"><a href="#使用Spring框架的好处是什么？" class="headerlink" title="使用Spring框架的好处是什么？"></a>使用Spring框架的好处是什么？</h3><ul>
<li><p>轻量：Spring 是轻量的，基本的版本大约2MB。</p>
</li>
<li><p>控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p>
</li>
<li><p>面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p>
</li>
<li><p>容器：Spring 包含并管理应用中对象的生命周期和配置。</p>
</li>
<li><p>MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</p>
</li>
<li><p>事务管理：Spring<br>提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</p>
</li>
<li><p>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or<br>JDO抛出的）转化为一致的unchecked 异常。</p>
</li>
</ul>
<h3 id="Spring的ApplicationContext通常的实现是什么"><a href="#Spring的ApplicationContext通常的实现是什么" class="headerlink" title="Spring的ApplicationContext通常的实现是什么?"></a>Spring的ApplicationContext通常的实现是什么?</h3><ul>
<li><p>Application Context 是 spring 中较高级的容器。和 BeanFactory<br>类似，它可以加载配置文件中定义的 bean，将所有的 bean<br>集中在一起，当有请求的时候分配 bean。<br>另外，它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的监听器。这个容器在<br>org.springframework.context.ApplicationContext interface 接口中定义。</p>
</li>
<li><p>ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于<br>BeanFactory，ApplicationContext 会被推荐使用。BeanFactory<br>仍然可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。</p>
</li>
</ul>
<h2 id="Spring与SpringMvc之间的相互关系"><a href="#Spring与SpringMvc之间的相互关系" class="headerlink" title="Spring与SpringMvc之间的相互关系"></a>Spring与SpringMvc之间的相互关系</h2><p>　　　　关系：父子关系</p>
<p>　　　　首先配置的是Spring容器的初始化加载的application文件，然后是SpringMVC的前端控制器（DispatchServlet），当配置完DispatchServlet后会在Spring容器中创建一个新的容器。其实这是两个容器，Spring作为父容器，SpringMVC作为子容器。 </p>
<p>　　　　<strong>这里需要说一些规则</strong>：儿子可以拿到父亲的Bean对象，而父亲不能拿到儿子的Bean，所以有时候会因为违法了这个而出现了报错，两者之间的顺序是很重要的</p>
<p>　　　　按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的Bean：Spring父容器负责所有其他非\@Controller注解的Bean的注册，而SpringMVC只负责\@Controller注解的Bean的注册，使得他们各负其责、明确边界。配置方式如下</p>
<p>Spring中BeanFactory和FactoryBean的区别？</p>
<p>BeanFactory:</p>
<p>以Factory结尾，表示它是一个工厂类(接口)，用于管理Bean的一个工厂。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p>
<p><img src="https://i.imgur.com/HV0VyA2.png" alt=""></p>
<p>FactoryBean:</p>
<p>以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean\&lt;T>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。</p>
<p>PrepareStatement与Statement的区别：</p>
<p>1.用PrepardStatement写成的sql语句，容易阅读，维护方便。批处理效率高，执行速度快。安全，可以防止sql注入攻击。缺点:当执行批处理时，你无法得知这个批处理总共影响了多少行。</p>
<p>2、Statement为每一条Sql语句生成执行计划， 如果要执行两条sql语句<br>select colume from table where colume=1;<br>select colume from table where colume=2;<br>会生成两个执行计划，一千个查询就生成一千个执行计划。而生成计划是非常消耗资源的</p>
<p>Spring框架是基于：core，context，bean构架的。</p>
<p>3．如何判断一个会话是否结束？</p>
<p>Session用来追踪每个用户的<a href="http://www.so.com/s?q=%E4%BC%9A%E8%AF%9D&amp;ie=utf-8&amp;src=internal_wenda_recommend_textn" target="_blank" rel="noopener">会话</a>，使用<a href="http://www.so.com/s?q=%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;ie=utf-8&amp;src=internal_wenda_recommend_textn" target="_blank" rel="noopener">服务器</a>生成的SessionID进行标识，用以区分用户。Session存放在服务器的<a href="http://www.so.com/s?q=%E5%86%85%E5%AD%98&amp;ie=utf-8&amp;src=internal_wenda_recommend_textn" target="_blank" rel="noopener">内存</a>中，SessionID存放在<a href="http://www.so.com/s?q=%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98&amp;ie=utf-8&amp;src=internal_wenda_recommend_textn" target="_blank" rel="noopener">服务器内存</a>和<a href="http://www.so.com/s?q=%E5%AE%A2%E6%88%B7%E6%9C%BA&amp;ie=utf-8&amp;src=internal_wenda_recommend_textn" target="_blank" rel="noopener">客户机</a>的Cookie里面。这样，当用户发出请求时，服务器将用户Cookie里面记录的SessionID和服务器内存中的SessionID进行比对，从而找到这个用户对应的Session进行操作。所以，如果客户机禁止Cookie的话，Session也不能使用，</p>
<p>4．Spring中bean的作用域？</p>
<p>在使用\@Repository、\@Controller、\@Service、\@Component这些注解声明Bean时，我们可以使用\@Scope来指定相关Bean的作用域。\@Scope后边可以跟不同的参数，根据这些参数来设定Bean的作用域。\@Scope可以跟下方的几个参数：</p>
<ul>
<li><p>Singleton:<br>单例Bean，当我们需要将一个Bean的作用域声明为单例时，我们可以使用Singleton来将相应的类声明为单例。Bean默认的Scope就是单例形式的。</p>
</li>
<li><p>Prototype：与单例相反，每次通过上下文获取的都是一个新的对象。</p>
</li>
<li><p>Session：Web Project中使用，同一session会话中为同一个对象。</p>
</li>
<li><p>Request：Web Project中使用，每次HTTP请求都会新建一个Bean。</p>
</li>
<li><p>GlobalSession: 在portal应用中有用，给每个global http<br>session新建一个Bean实例。</p>
</li>
</ul>
<ol>
<li>spring中单例是安全的吗？</li>
</ol>
<blockquote>
<p>  Singleton通过将构造方法限定为private避免了类在外部被实例化（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效，这里不考虑反射机制的存在），在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。但是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例；</p>
</blockquote>
<p>5．Http的工作原理？</p>
<p><img src="https://i.imgur.com/mEi2fA8.png" alt=""></p>
<blockquote>
<p>  以下是HTTP请求/响应的步骤：</p>
</blockquote>
<blockquote>
<p>  （1）客户端连接到Web服务器</p>
</blockquote>
<blockquote>
<p>  一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn。" target="_blank" rel="noopener">http://www.oakcms.cn。</a></p>
</blockquote>
<blockquote>
<p>  （2）发送HTTP请求</p>
</blockquote>
<blockquote>
<p>  通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
</blockquote>
<blockquote>
<p>  （3）服务器接受请求并返回HTTP响应</p>
</blockquote>
<blockquote>
<p>  Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
</blockquote>
<blockquote>
<p>  （4）释放连接TCP连接</p>
</blockquote>
<blockquote>
<p>  Web服务器主动关闭TCP套接字，释放TCP连接；客户端被动关闭TCP套接字，释放TCP连接。</p>
</blockquote>
<blockquote>
<p>  （5）客户端浏览器解析HTML内容</p>
</blockquote>
<blockquote>
<p>  6．Ajax请求</p>
</blockquote>
<blockquote>
<p>  ①原生js写法：</p>
</blockquote>
<blockquote>
<p>  \&lt;script type=”text/javascript”></p>
</blockquote>
<blockquote>
<p>  <strong>var</strong> xmlHttp;</p>
</blockquote>
<blockquote>
<p>  <strong>function</strong> createXMLHttpRequest(){</p>
</blockquote>
<blockquote>
<p>  //如果是IE浏览器则创建一个ActiveXObject(“Microsoft.XMLHTTP”)</p>
</blockquote>
<blockquote>
<p>  <strong>if</strong>(window.ActiveXObject)</p>
</blockquote>
<blockquote>
<p>  xmlHttp = <strong>new</strong> ActiveXObject(“Microsoft.XMLHTTP”);</p>
</blockquote>
<blockquote>
<p>  //非ie浏览器</p>
</blockquote>
<blockquote>
<p>  <strong>else if</strong>(window.XMLHttpRequest)</p>
</blockquote>
<blockquote>
<p>  xmlHttp = <strong>new</strong> XMLHttpRequest();</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  <strong>function</strong> startRequest(){</p>
</blockquote>
<blockquote>
<p>  //1. 获取XMLHttpRequest，注意不同的浏览器的获取方式:</p>
</blockquote>
<blockquote>
<p>  createXMLHttpRequest();</p>
</blockquote>
<blockquote>
<p>  //2. 设置请求地址和请求方式 ,get/post</p>
</blockquote>
<blockquote>
<p>  xmlHttp.open(“GET”,”ajax/ajaxDemo1”+<strong>new</strong> Date().getTime(),<strong>true</strong>);</p>
</blockquote>
<blockquote>
<p>  //3. 设置该对象的状态改变时候的回调方法</p>
</blockquote>
<blockquote>
<p>  xmlHttp.onreadystatechange = <strong>function</strong>(){</p>
</blockquote>
<blockquote>
<p>  //3.1 判断状态为4(处理完成)和http响应码为200(成立成功)再做处理,</p>
</blockquote>
<blockquote>
<p>  <strong>if</strong>(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)</p>
</blockquote>
<blockquote>
<p>  //3.2 获取响应的结果文本</p>
</blockquote>
<blockquote>
<p>  alert(“服务器返回: “ + xmlHttp.responseText);</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  //4. 发送请求send(null)，当请求为post时可以为send(String)</p>
</blockquote>
<blockquote>
<p>  xmlHttp.send(<strong>null</strong>);</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  ⑵jquery写法：</p>
</blockquote>
<blockquote>
<p>  function ajax(){</p>
</blockquote>
<blockquote>
<p>  $.ajax({</p>
</blockquote>
<blockquote>
<p>  type:”get”,//请求方式可以为get、post等</p>
</blockquote>
<blockquote>
<p>  <a href="url:" target="_blank" rel="noopener">url:””,//</a>请求地址</p>
</blockquote>
<blockquote>
<p>  data:”attribute=value”,//请求信息也可以为{attribute:”value”}</p>
</blockquote>
<blockquote>
<p>  success:function(data){//回调方法</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  });</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  function doGet(parameter){</p>
</blockquote>
<blockquote>
<p>  $.get({</p>
</blockquote>
<blockquote>
<p>  “url?”+parameter, function(data){</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  });</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  function doPost(data){</p>
</blockquote>
<blockquote>
<p>  $.post({</p>
</blockquote>
<blockquote>
<p>  url,data,function(){</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  });</p>
</blockquote>
<blockquote>
<p>  }</p>
</blockquote>
<blockquote>
<p>  使用jquery实现ajax请求常用的参数：</p>
</blockquote>
<blockquote>
<p>  Type:请请请方式</p>
</blockquote>
<blockquote>
<p>  Data：请求的数据</p>
</blockquote>
<blockquote>
<p>  Catch：是否需要调用缓存</p>
</blockquote>
<blockquote>
<p>  ContentType：请求的数据类型</p>
</blockquote>
<blockquote>
<p>  Datatype：后响应的数据类型</p>
</blockquote>
<blockquote>
<p>  Error：错误时的回调函数</p>
</blockquote>
<blockquote>
<p>  Async：是否同步</p>
</blockquote>
<blockquote>
<p>  Json数据的写法：</p>
</blockquote>
<blockquote>
<p>  {name:”value”,age:”value”}</p>
</blockquote>
<blockquote>
<p>  {“name=value1&amp;age=value1”}</p>
</blockquote>
<blockquote>
<p>  [{name:”value”,age:”value”},{“name=value1&amp;age=value1”}]—数组</p>
</blockquote>
<blockquote>
<p>  \&lt;/script></p>
</blockquote>
<blockquote>
<p>  7．Xml与Json的优点和缺点</p>
</blockquote>
<blockquote>
<p>  一般而言：配置文件用XML,传输数据用JSON（所谓的轻量级体现的解析上）；</p>
</blockquote>
<blockquote>
<p>  逐步解析用XML（SAX技术可以边传输边解析），整体解析用JSON（目前只能整体一次性解析）；</p>
</blockquote>
<blockquote>
<p>  so，大规模数据传输用XML，小数据用JSON。</p>
</blockquote>
<blockquote>
<p>  XML和JSON优缺点</p>
</blockquote>
<blockquote>
<p>  (1).XML的优缺点<br>  &lt;1>.XML的优点<br>  　　A.格式统一，符合标准；<br>  　　B.容易与其他系统进行远程交互，数据共享比较方便。<br>  &lt;2>.XML的缺点<br>  　　A.XML文件庞大，文件格式复杂，传输占带宽；<br>  　　B.服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护；<br>  　　C.客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码；<br>  　　D.服务器端和客户端解析XML花费较多的资源和时间。</p>
</blockquote>
<blockquote>
<p>  (2).JSON的优缺点<br>  &lt;1>.JSON的优点：<br>  　　A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；<br>  　　B.易于解析，客户端JavaScript可以简单的通过eval_r()进行JSON数据的读取；<br>  　　C.支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript,<br>  Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；<br>  　　D.在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；<br>  　　E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。<br>  &lt;2>.JSON的缺点<br>  　　A.没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性；<br>  　　B.JSON格式目前在Web Service中推广还属于初级阶段。</p>
</blockquote>
<p><img src="https://i.imgur.com/UT8ZJws.png" alt=""></p>
<blockquote>
<p>  8.操作数据库时要随时提交；操作文档时随时保存；</p>
</blockquote>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/其它/">其它</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Struts2面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/13/Struts2面试题/" class="article-date">
      <time datetime="2018-08-13T08:34:43.000Z" itemprop="datePublished">2018-08-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/13/Struts2面试题/">Struts2操作步骤</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Struts2操作步骤：</p>
<ol>
<li>新建web.xml：</li>
</ol>
<blockquote>
<p>  ①加载名称为struts2.xml文件；</p>
</blockquote>
<blockquote>
<p>  ②加载默认主页面index.xml</p>
</blockquote>
<blockquote>
<p>  \&lt;?xml version=”1.0” encoding=”UTF-8”?></p>
</blockquote>
<blockquote>
<p>  \&lt;web-app xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>  xmlns=”<a href="http://java.sun.com/xml/ns/j2ee&quot;" target="_blank" rel="noopener">http://java.sun.com/xml/ns/j2ee&quot;</a><br>  xmlns:web=”<a href="http://xmlns.jcp.org/xml/ns/javaee&quot;" target="_blank" rel="noopener">http://xmlns.jcp.org/xml/ns/javaee&quot;</a><br>  xsi:schemaLocation=”<a href="http://xmlns.jcp.org/xml/ns/javaee" target="_blank" rel="noopener">http://xmlns.jcp.org/xml/ns/javaee</a><br>  <a href="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd</a><br>  <a href="http://java.sun.com/xml/ns/j2ee" target="_blank" rel="noopener">http://java.sun.com/xml/ns/j2ee</a><br>  <a href="http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;" target="_blank" rel="noopener">http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;</a> id=”WebApp_9”<br>  version=”2.4”></p>
</blockquote>
<blockquote>
<p>  &lt;display-name>strutsdemo\&lt;/display-name></p>
</blockquote>
<blockquote>
<p>  &lt;filter></p>
</blockquote>
<blockquote>
<p>  &lt;!– 此处的struts2表示默认的jar包中的struts2的servlet–></p>
</blockquote>
<blockquote>
<p>  &lt;filter-name>struts2\&lt;/filter-name><br>  &lt;filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\&lt;/filter-class></p>
</blockquote>
<blockquote>
<p>  &lt;/filter></p>
</blockquote>
<blockquote>
<p>  &lt;filter-mapping></p>
</blockquote>
<blockquote>
<p>  &lt;filter-name>struts2\&lt;/filter-name></p>
</blockquote>
<blockquote>
<p>  &lt;url-pattern>/*\&lt;/url-pattern></p>
</blockquote>
<blockquote>
<p>  &lt;/filter-mapping></p>
</blockquote>
<blockquote>
<p>  &lt;welcome-file-list></p>
</blockquote>
<blockquote>
<p>  &lt;welcome-file>index.jsp\&lt;/welcome-file></p>
</blockquote>
<blockquote>
<p>  &lt;/welcome-file-list></p>
</blockquote>
<blockquote>
<p>  &lt;/web-app></p>
</blockquote>
<ol>
<li>src目录下新建struts.xml：</li>
</ol>
<blockquote>
<p>  &lt;?xml version=”1.0” encoding=”UTF-8”?></p>
</blockquote>
<blockquote>
<p>  &lt;!DOCTYPE struts PUBLIC “-//Apache Software Foundation//DTD Struts<br>  Configuration 2.1//EN” “<a href="http://struts.apache.org/dtds/struts-2.1.dtd&quot;\&gt;" target="_blank" rel="noopener">http://struts.apache.org/dtds/struts-2.1.dtd&quot;\&gt;</a></p>
</blockquote>
<blockquote>
<p>  &lt;struts></p>
</blockquote>
<blockquote>
<p>  &lt;!– 资源文件的配置 –></p>
</blockquote>
<blockquote>
<p>  &lt;constant name=”struts.custom.i18n.resources”<br>  value=”studentInformation.resource” /></p>
</blockquote>
<blockquote>
<p>  &lt;!– 通过以下标签可以修改页面的后缀名 –></p>
</blockquote>
<blockquote>
<p>  &lt;constant name=”struts.action.extension”<br>  value=”do,go,action,shtml”>\&lt;/constant></p>
</blockquote>
<blockquote>
<p>  &lt;!– 指定常量 ,最大文件为8MB–></p>
</blockquote>
<blockquote>
<p>  &lt;constant name=”struts.multipart.maxSize” value=”86170804”>\&lt;/constant></p>
</blockquote>
<blockquote>
<p>  &lt;!–多个配置文件,通过struts.xml来将其他三个xml整合到一块 –></p>
</blockquote>
<blockquote>
<p>  &lt;include file=”struts-user-one.xml”>\&lt;/include></p>
</blockquote>
<blockquote>
<p>  &lt;include file=”<em>struts-user-two.xml</em>“>\&lt;/include></p>
</blockquote>
<blockquote>
<p>  &lt;include file=”struts-user-three.xml”>\&lt;/include></p>
</blockquote>
<blockquote>
<p>  &lt;include file=”struts-user-day0527.xml”>\&lt;/include></p>
</blockquote>
<blockquote>
<p>  &lt;include file=”struts-user-day0527Login.xml”>\&lt;/include></p>
</blockquote>
<blockquote>
<p>  &lt;include file=”struts-user-day0528.xml”>\&lt;/include></p>
</blockquote>
<blockquote>
<p>  &lt;include file=”struts-user-day0529.xml”>\&lt;/include></p>
</blockquote>
<blockquote>
<p>  &lt;include file=”struts-user-day0530.xml”>\&lt;/include></p>
</blockquote>
<blockquote>
<p>  &lt;!–</p>
</blockquote>
<blockquote>
<p>  默认视图主题</p>
</blockquote>
<blockquote>
<p>  &lt;constant name=”struts.devMode” value=”true”>\&lt;/constant></p>
</blockquote>
<blockquote>
<p>  –></p>
</blockquote>
<blockquote>
<p>  &lt;!–</p>
</blockquote>
<blockquote>
<p>  与spring集成时 ，指定负责springaction对象的创建</p>
</blockquote>
<blockquote>
<p>  &lt;constant name=”struts.objectFactory” value=”spring”>\&lt;/constant></p>
</blockquote>
<blockquote>
<p>  –></p>
</blockquote>
<blockquote>
<p>  &lt;!–</p>
</blockquote>
<blockquote>
<p>  设置struts是否支持动态方法调用，该属性默认为true，若想关闭动态调用，则可以设置为false</p>
</blockquote>
<blockquote>
<p>  &lt;constant name=”struts.enableDvnamicMethodlnvocation”<br>  value=”false”>\&lt;/constant></p>
</blockquote>
<blockquote>
<p>  –></p>
</blockquote>
<blockquote>
<p>  &lt;!–</p>
</blockquote>
<blockquote>
<p>  设置上传文件大小的限制</p>
</blockquote>
<blockquote>
<p>  &lt;constant name=”struts.multipart.maxsize” value=”107010967”>\&lt;/constant></p>
</blockquote>
<blockquote>
<p>  –></p>
</blockquote>
<blockquote>
<p>  &lt;!–</p>
</blockquote>
<blockquote>
<p>  结果类型：&lt;result name=”success” type=”dispatcher”>\&lt;/result></p>
</blockquote>
<blockquote>
<p>  默认为success,dispatcher，表示请求转发，也可以为redirect表示重定向，或者stream表示流</p>
</blockquote>
<blockquote>
<p>  velocity，freemaker表示模版</p>
</blockquote>
<blockquote>
<p>  –></p>
</blockquote>
<blockquote>
<p>  &lt;!– &lt;package name=”day0509” namespace=”/day0509”<br>  extends=”struts-default”></p>
</blockquote>
<blockquote>
<p>  中：</p>
</blockquote>
<blockquote>
<p>  name：是自定义的，没有特别意义；</p>
</blockquote>
<blockquote>
<p>  namespace：是核心部分在name前加“/”，表示二级目录，因为所有的访问都是通过url-pattern实现链接的</p>
</blockquote>
<blockquote>
<p>  extends：是默认的</p>
</blockquote>
<blockquote>
<p>  \&lt;action name=”mystruts0509” class=”Struts01.MyStrutsAction”></p>
</blockquote>
<blockquote>
<p>  中：</p>
</blockquote>
<blockquote>
<p>  name：是自定义的action名称，其后省略.action，此处的name与上面的namespace共同构成一个url即：/day0509/mystruts0509.action</p>
</blockquote>
<blockquote>
<p>  class:表示具体的工作是由该类来完成的</p>
</blockquote>
<blockquote>
<p>  &lt;result name=”sucess” type=”dispatcher”>/sucess0509.jsp\&lt;/result></p>
</blockquote>
<blockquote>
<p>  中：</p>
</blockquote>
<blockquote>
<p>  name：示如果action标签中的class类执行返回的结果为与该name的值相同，则执行该result标签中的jsp或html页面</p>
</blockquote>
<blockquote>
<p>  type:是默认的</p>
</blockquote>
<blockquote>
<p>  –></p>
</blockquote>
<blockquote>
<p>  &lt;package name=”day0509” namespace=”/day0509” extends=”struts-default”></p>
</blockquote>
<blockquote>
<p>  &lt;action name=”mystruts0509” class=”Struts01.MyStrutsAction”></p>
</blockquote>
<blockquote>
<p>  &lt;result name=”sucess” type=”dispatcher”>/sucess0509.jsp\&lt;/result></p>
</blockquote>
<blockquote>
<p>  &lt;/action></p>
</blockquote>
<blockquote>
<p>  &lt;/package></p>
</blockquote>
<blockquote>
<p>  &lt;!– 第二个action ,路径：href=”day0526/mystruts0526.action”<br>  ,注：一个packag可以写多个action –></p>
</blockquote>
<blockquote>
<p>  &lt;package name=”day0526” namespace=”/day0526” extends=”struts-default”></p>
</blockquote>
<blockquote>
<p>  &lt;!–default-action-ref表示在当前package中找不到指定的路径时，自动使用调用该action，可以避免404错误<br>  –></p>
</blockquote>
<blockquote>
<p>  &lt;default-action-ref name=”mystruts0526”>\&lt;/default-action-ref></p>
</blockquote>
<blockquote>
<p>  &lt;action name=”mystruts0526” class=”Struts02.ActionDemo1”></p>
</blockquote>
<blockquote>
<p>  &lt;result name=”success” type=”dispatcher”>/day0526.jsp\&lt;/result></p>
</blockquote>
<blockquote>
<p>  &lt;/action></p>
</blockquote>
<blockquote>
<p>  &lt;!– 打开jsp页面的方法： –></p>
</blockquote>
<blockquote>
<p>  &lt;action name=”NoActionDemo” class=”Struts02.NoactionDemo”></p>
</blockquote>
<blockquote>
<p>  &lt;result name=”sucess” type=”dispatcher”>/day0526NoAction.jsp\&lt;/result></p>
</blockquote>
<blockquote>
<p>  &lt;/action></p>
</blockquote>
<blockquote>
<p>  &lt;!–<br>  不指定class和result中的name，此方法的好处是省略了上面方法中的Struts02.NoactionDemo类<br>  –></p>
</blockquote>
<blockquote>
<p>  &lt;action name=”NoActionDemo2”></p>
</blockquote>
<blockquote>
<p>  &lt;result type=”dispatcher”>/day0526NoAction.jsp\&lt;/result></p>
</blockquote>
<blockquote>
<p>  &lt;/action></p>
</blockquote>
<blockquote>
<p>  &lt;/package></p>
</blockquote>
<blockquote>
<p>  &lt;package name=”day05261” namespace=”/day0526/mm/m1/m2”<br>  extends=”struts-default”></p>
</blockquote>
<blockquote>
<p>  &lt;action name=”mystruts0526” class=”Struts02.ActionDemo2”></p>
</blockquote>
<blockquote>
<p>  &lt;result name=”success” type=”dispatcher”>/day0526.jsp\&lt;/result></p>
</blockquote>
<blockquote>
<p>  &lt;/action></p>
</blockquote>
<blockquote>
<p>  &lt;/package></p>
</blockquote>
<blockquote>
<p>  &lt;/struts></p>
</blockquote>
<blockquote>
<p>  Struts1工作机制：</p>
</blockquote>
<blockquote>
<p>  -(1)检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息;<br>  -(2)如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中;<br>  -(3)根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法;<br>  -(4)如果ActionForm的validate()方法返回或返回一个不包含ActionMessage的ActuibErrors对象,<br>  就表示表单验证成功;<br>  -(5)ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的<br>  Action实例不存在,就先创建这个实例,然后调用Action的execute()方法;<br>  -(6)Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给<br>  ActionForward对象指向的JSP组件;<br>  -(7)ActionForward对象指向JSP组件生成动态网页,返回给客户;</p>
</blockquote>
<p>3.struts2与struts1的区别：</p>
<p>①struts2的mvc模式：当用户在页面提交用户请求时,该请求需要提交给struts2的控<br>制器处理。struts2的控制器根据处理结果,<br>决定将哪个页面呈现给客户端。<br>与struts1最大的不同是：struts2的控制器。struts2的控制器不再像struts1的控<br>制器,需要继承一个Action父类,甚至可以无需实现<br>任何接口,struts2的Action就是一个普通的POJO。实际上，Struts2 的Action就是<br>一个包含execute方法的普通Java类<br>该类里包含的多个属性用于封装用户的请求参数。</p>
<p>Struts2的工作原理？<br><img src="https://i.imgur.com/XZjKUXh.gif" alt=""></p>
<p>一个请求在Struts2框架中的处理大概分为以下几个步骤(可查看源码：<em><a href="https://github.com/apache/struts" target="_blank" rel="noopener">https://github.com/apache/struts</a></em>):<br><strong>1 客户端初始化一个指向Servlet容器（例如Tomcat）的请求</strong><br><strong>2这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh<br>Plugin） </strong><br><strong>3接着FilterDispatcher（现已过时）被调用，FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action </strong><br><strong>4如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy </strong><br><strong>5 ActionProxy通过Configuration<br>Manager询问框架的配置文件，找到需要调用的Action类 </strong><br><strong>6 ActionProxy创建一个ActionInvocation的实例。</strong><br><strong>7<br>ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。 </strong><br><strong>8一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可<br>能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2<br>框架中继承的标签。在这个过程中需要涉及到ActionMapper</strong></p>
<p><strong>4.struts是什么？</strong></p>
<p>struts1是基于JSP和servlet的一个开源的Web应用框架，使用的是MVC的设计模式。struts2是基于webwork技术的框架，是sun和webwork公司联手开发的一个功能非常齐全的框架，struts2和struts1没有任何关系，是一个全新的框架</p>
<h3 id="5-JSF是什么？"><a href="#5-JSF是什么？" class="headerlink" title="5.JSF是什么？"></a>5.JSF是什么？</h3><p>JavaServer Face是基于组件的web开发框架，跟sturts差不多的框架</p>
<h3 id="12-jsp静态包含和动态包含的区别"><a href="#12-jsp静态包含和动态包含的区别" class="headerlink" title="12.jsp静态包含和动态包含的区别?"></a>12.jsp静态包含和动态包含的区别?</h3><ul>
<li><p>\&lt;%\@ include file=”” %>是指令元素，静态包含。\&lt;jsp:include page=””<br>/>是行为元素，动态包含。</p>
</li>
<li><p>最终编译成java文件的数目不同。 >1.<br>静态包含在转换成为java文件的时候将包含文件的内容“复制”到主体文件，然后作为一个整体编译。生成一个以包含页面命名的servlet和class文件。<br>>2. 动态包含是各个jsp文件分别转换，分别编译。最终编程成多个java文件。</p>
</li>
<li><p>执行时间不同 > <em>静态包含发生在：JSP生成class文件阶段。<br>> </em>动态包含发生在：执行class文件阶段。动态加入。</p>
</li>
<li><p>静态包含在两个文件中不能有相同的变量，动态包含允许。</p>
</li>
<li><p>无论是动态包含还是静态包含，其request对象都是相同的。也就是同一个request对象</p>
</li>
</ul>
<p><strong>13.struts2与spring的区别:</strong></p>
<p>1.struts2：action/拦截器/xml配置</p>
<p>M:model部分比较弱，action本身就是一个model；</p>
<blockquote>
<p>  C: 控制器是类级别，通过xml来识别，附加功能可以通过自定义拦截器实现</p>
</blockquote>
<p>V:jsp+struts标签</p>
<p>2.springMvc：controller/注解</p>
<p>M:单独有一个参数是model数据；</p>
<p>V:viewResolver和其他视图解析器，也提供了标签实现；</p>
<p>C:控制器在方法级别，所有功能通过注解来实现；</p>
<p>3.springMvc五层结构的分离中自带spring，能够更好的融合；</p>
<p>使用注解的方式，更加方便，没有大量的xml配置；</p>
<p>在代码上注解和执行方法在一块，更容易维护；</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/其它/">其它</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-MyBatista面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/13/MyBatista面试题/" class="article-date">
      <time datetime="2018-08-13T08:33:37.000Z" itemprop="datePublished">2018-08-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/13/MyBatista面试题/">MyBatista的工作原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>1.MyBatista的工作原理：<br><img src="https://i.imgur.com/UalsAYz.png" alt=""></p>
<p><strong>原理详解：</strong></p>
<p>MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个SqlSession。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭SqlSession。</p>
<p>优点：</p>
<p>1、简单易学</p>
<p> mybatis本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</p>
<p>2、灵活</p>
<pre><code>mybatis不会对应用程序或者数据库的现有设计强加任何影响。
</code></pre><p>sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。</p>
<p>3、解除sql与程序代码的耦合</p>
<p> 通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</p>
<p>4、提供映射标签，支持对象与数据库的orm字段关系映射</p>
<p>5、提供对象关系映射标签，支持对象关系组建维护</p>
<p>6、提供xml标签，支持编写动态sql</p>
<p>缺点：</p>
<p>1、编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。</p>
<p>2、SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。</p>
<p>3、框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</p>
<p>4、二级缓存机制不佳</p>
<p>mybatis的优点同样是mybatis的缺点，正因为mybatis使用简单，数据的可靠性、完整性的瓶颈便更多依赖于程序员对sql的使用水平上了。sql写在xml里，虽然方便了修改、优化和统一浏览，但可读性很低，调试也非常困难，也非常受限。</p>
<p>常见面试题：</p>
<h4 id="1、-和-的区别是什么？"><a href="#1、-和-的区别是什么？" class="headerlink" title="1、#{}和\${}的区别是什么？"></a>1、#{}和\${}的区别是什么？</h4><p>注：这道题是面试官面试我同事的。</p>
<p>答：\${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如\${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0,<br>parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。</p>
<h4 id="2、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#2、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="2、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>2、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h4><p>答：还有很多其他的标签，\&lt;resultMap>、\&lt;parameterMap>、\&lt;sql>、\&lt;include>、&lt;selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中\&lt;sql>为sql片段标签，通过\&lt;include>标签引入sql片段，&lt;selectKey>为不支持自增的主键生成策略标签</p>
<p>3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</p>
<p>答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id<br>= findStudentById的MappedStatement。在Mybatis中，每一个\&lt;select>、\&lt;insert>、&lt;update>、\&lt;delete>标签，都会被解析为一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h4 id="4、Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#4、Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="4、Mybatis是如何进行分页的？分页插件的原理是什么？"></a>4、Mybatis是如何进行分页的？分页插件的原理是什么？</h4><p>答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：select * from student，拦截sql后重写为：select t.* from （select * from<br>student）t limit 0，10</p>
<h4 id="5、简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#5、简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="5、简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>5、简述Mybatis的插件运行原理，以及如何编写一个插件。</h4><p>答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h4 id="6、Mybatis执行批量插入，能返回数据库主键列表吗？"><a href="#6、Mybatis执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="6、Mybatis执行批量插入，能返回数据库主键列表吗？"></a>6、Mybatis执行批量插入，能返回数据库主键列表吗？</h4><p>答：能，JDBC都能，Mybatis当然也能。</p>
<h4 id="7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h4><p>答：Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p>
<p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>
<h4 id="8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h4><p>答：第一种是使用\&lt;resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS<br>NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS<br>NaMe，Mybatis一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h4 id="9、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#9、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="9、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>9、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h4><p>答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map\&lt;String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
<h4 id="10、Mybatis中如何执行批处理？"><a href="#10、Mybatis中如何执行批处理？" class="headerlink" title="10、Mybatis中如何执行批处理？"></a>10、Mybatis中如何执行批处理？</h4><p>答：使用BatchExecutor完成批处理。</p>
<h4 id="11、Mybatis是否可以映射Enum枚举类？"><a href="#11、Mybatis是否可以映射Enum枚举类？" class="headerlink" title="11、Mybatis是否可以映射Enum枚举类？"></a>11、Mybatis是否可以映射Enum枚举类？</h4><p>答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p>
<h4 id="12、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#12、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="12、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>12、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h4><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，\&lt;parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。\&lt;resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个\&lt;select>、\&lt;insert>、\&lt;update>、\&lt;delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h4 id="13、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#13、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="13、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>13、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h4><p>答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<p>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的Mybatis系列博客中都有详细讲解和原理分析。</p>
<p>14．MyBatis关联查询</p>
<ol start="5">
<li>解决表的字段名与实体类的属性名不相同的冲突</li>
</ol>
<p>a. 准备表和数据：</p>
<p>CREATE TABLE t_user_example(</p>
<p>t_id number(11),</p>
<p>t_name varchar2(32),</p>
<p>t_age number</p>
<p>);</p>
<p>b. 定义实体类：</p>
<p>public class User {</p>
<p>private int id;</p>
<p>private String name;</p>
<p>private int age;</p>
<p>}</p>
<p>c. 实现对查询</p>
<p>one. 通过在sql语句中定义别名</p>
<p>&lt;select id=”selectUserByUserId” parameterType=”int”<br>resultType=”com.entity.User”></p>
<p>select t_id id, t_name name,t_age age from t_user_example where t_id=#{id}</p>
<p>&lt;/select></p>
<p>Two. 定义\&lt;resultMap></p>
<p>&lt;select id=”selectUserByUserIdResultMap” parameterType=”int”<br>resultMap=”userResultMap”></p>
<p>select * from t_user_example where t_id=#{id}</p>
<p>&lt;/select></p>
<p>&lt;resultMap type=”com.entity.User” id=”userResultMap”></p>
<p>&lt;id property=”id” column=”t_id”/></p>
<p>&lt;result property=”name” column=”t_name”/></p>
<p>&lt;result property=”age” column=”t_age”/></p>
<p>&lt;/resultMap></p>
<ol start="6">
<li>实现联表查询</li>
</ol>
<p>1). 一对一：</p>
<p>a. 创建表和数据：</p>
<p>CREATE TABLE t_user(</p>
<p>u_id number(11) primary key,</p>
<p>u_name varchar2(32),</p>
<p>c_id number(11),</p>
<p>FOREIGN KEY (c_id) REFERENCES t_user_card(c_id)</p>
<p>);</p>
<p>CREATE TABLE t_user_card(</p>
<p>c_id number(11) primary key,</p>
<p>c_number varchar2(18)</p>
<p>);</p>
<p>INSERT INTO t_user(u_id,u_name,c_id) VALUES(1,’Tom’,1);</p>
<p>INSERT INTO t_user(u_id,u_name,c_id) VALUES(2,’Jack’,1);</p>
<p>INSERT INTO t_user_card(c_id,c_number) VALUES(1,’420983198000000000’);</p>
<p>INSERT INTO t_user_card(c_id,c_number) VALUES(2,’420983198888888888’);</p>
<p>b. 定义实体类：</p>
<p>public class User {</p>
<p>private int id;</p>
<p>private String name;</p>
<p>private UserCard userCard;</p>
<p>}</p>
<p>public class UserCard {</p>
<p>private int id;</p>
<p>private String number;</p>
<p>}</p>
<p>c. 定义sql映射文件UserMapper.xml：</p>
<p>&lt;!– 方式一：嵌套查询方式, 通过执行另外一个SQL映射语句来返回预期的复杂类型 –></p>
<p>&lt;select id=”showUserByUserId” parameterType=”int” resultMap=”UserResultMap”></p>
<p>select * from t_user where u_id=#{id}</p>
<p>&lt;/select></p>
<p>&lt;resultMap type=”User” id=”UserResultMap”></p>
<p>&lt;id column=”u_id” property=”id”/></p>
<p>&lt;result column=”u_name” property=”name”/></p>
<p>&lt;association property=”userCard” javaType=”com.entity.UserCard” column=”c_id”<br>select=”getUserCard”>\&lt;/association></p>
<p>&lt;/resultMap></p>
<p>&lt;select id=”getUserCard” parameterType=”int” resultType=”com.entity.UserCard”></p>
<p>select c_id id, c_number number from t_user_card where c_id=#{id}</p>
<p>&lt;/select></p>
<p>&lt;!–</p>
<p>方式二：嵌套结果：使用嵌套结果映射来处理重复的联合结果的子集</p>
<p>–></p>
<p>&lt;select id=”showUserByUserId_2” parameterType=”int”<br>resultMap=”UserResultMap_2”></p>
<p>select * from t_user u,t_user_card c where u.u_id=#{id} and u.c_id=c.c_id;</p>
<p>&lt;/select></p>
<p>&lt;resultMap type=”com.entity.User” id=”UserResultMap_2”></p>
<p>&lt;id column=”u_id” property=”id”/></p>
<p>&lt;result column=”u_name” property=”name”/></p>
<p>&lt;association column=”c_id” property=”userCard” javaType=”com.entity.UserCard”></p>
<p>&lt;id column=”c_id” property=”id”/></p>
<p>&lt;result column=”c_number” property=”number”/></p>
<p>&lt;/association></p>
<p>&lt;/resultMap></p>
<p>d. 测试：</p>
<p>@Test</p>
<p>public void test1() {</p>
<p>SqlSession session = sessionFactory.openSession(true);</p>
<p>User u = sqlSession.selectOne(“mybatis.UserMapper.showUserByUserId”, 1);</p>
<p>System.out.println(u);</p>
<p>}</p>
<p>@Test</p>
<p>public void test2() {</p>
<p>SqlSession session = sessionFactory.openSession(true);</p>
<p>User u = sqlSession.selectOne(“mybatis.UserMapper.showUserByUserId_2”, 1);</p>
<p>System.out.println(u);</p>
<p>}</p>
<p>2) 一对多</p>
<p>a. 创建表和数据：</p>
<p>CREATE TABLE t_address(</p>
<p>a_id number(11) primary key,</p>
<p>a_name varchar2(200),</p>
<p>u_id number(11)</p>
<p>);</p>
<p>INSERT INTO t_address(a_id,a_name, u_id) VALUES(‘移动’, 1);</p>
<p>INSERT INTO t_address(a_id,a_name, u_id) VALUES(‘电信’, 1);</p>
<p>INSERT INTO t_address(a_id,a_name, u_id) VALUES(‘网通’, 1);</p>
<p>INSERT INTO t_address(a_id,a_name, u_id) VALUES(‘联通’, 2);</p>
<p>INSERT INTO t_address(a_id,a_name, u_id) VALUES(‘铁通’, 2);</p>
<p>INSERT INTO t_address(a_id,a_name, u_id) VALUES(‘中通’, 2);</p>
<p>b. 定义实体类：</p>
<p>public class Address {</p>
<p>private int id;</p>
<p>private String name;</p>
<p>}</p>
<p>public class User {</p>
<p>private int id;</p>
<p>private String name;</p>
<p>private UserCard userCard;</p>
<p>private List\&lt;Address> addresss;</p>
<p>}</p>
<p>c. 定义sql映射文件UserMapper.xml：(根据userId查询对应的个人信息和联系方式)</p>
<p>&lt;!– 集合的嵌套结果：使用嵌套结果映射来处理重复的联合结果的子集–></p>
<p>&lt;select id=”showUserByUserId_3” parameterType=”int”<br>resultMap=”UserResultMap3”></p>
<p>select * from t_user u,t_user_card c, t_address a where u.u_id=#{id} and<br>u.c_id=c.c_id and u.u_id=a.u_id</p>
<p>&lt;/select></p>
<p>&lt;resultMap type=”com.entity.User” id=”UserResultMap3”></p>
<p>&lt;id column=”u_id” property=”id”/></p>
<p>&lt;result column=”u_name” property=”name”/></p>
<p>&lt;association column=”c_id” property=”userCard” javaType=”com.entity.UserCard”></p>
<p>&lt;id column=”c_id” property=”id”/></p>
<p>&lt;result column=”c_number” property=”number”/></p>
<p>&lt;/association></p>
<p>&lt;collection property=”addresss” ofType=”com.entity.Address”<br>javaType=”ArrayList”></p>
<p>&lt;id property=”id” column=”a_id” /></p>
<p>&lt;result property=”name” column=”a_name”/></p>
<p>&lt;/collection></p>
<p>&lt;/resultMap></p>
<p>&lt;!– 集合的嵌套查询方式, 通过执行另外一个SQL映射语句来返回预期的复杂类型 –></p>
<p>&lt;select id=”showUserByUserId_4” parameterType=”int”<br>resultMap=”UserResultMap4”></p>
<p>select * from t_user u where u.u_id=#{id}</p>
<p>&lt;/select></p>
<p>&lt;resultMap type=”com.entity.User” id=”UserResultMap4”></p>
<p>&lt;id column=”u_id” property=”id”/></p>
<p>&lt;result column=”u_name” property=”name”/></p>
<p>&lt;association property=”userCard” javaType=”com.entity.UserCard” column=”c_id”<br>select=”getUserCard”>\&lt;/association></p>
<p><collection property="addresss" oftype="com.entity.Address" column="u_id" select="getAddressSelect" \="">\&lt;/collection></collection></p>
<p>&lt;/resultMap></p>
<p>&lt;select id=”getUserCard” parameterType=”int” resultType=”com.entity.UserCard”></p>
<p>select c_id id, c_number number from t_user_card where c_id=#{id}</p>
<p>&lt;/select></p>
<select id="getAddressSelect" parametertype="int" resulttype="com.entity.Address" \="">

<p>select a_id id, a_name name from t_address where u_id=#{id}</p>
<p>&lt;/select></p>
<p>8．前端</p>
<p>Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量</p>
</li>
<li><p>避免用户不断刷新或者跳转页面，提高用户体验</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>对搜索引擎不友好（</p>
</li>
<li><p>要实现ajax下的前后退功能成本较大</p>
</li>
<li><p>可能造成请求数的增加</p>
</li>
<li><p>跨域问题限制</p>
</li>
</ul>
<p>JSON是一种轻量级的数据交换格式，ECMA的一个子集</p>
<p>优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）</p>
<h3 id="1-介绍js的基本数据类型"><a href="#1-介绍js的基本数据类型" class="headerlink" title="1.介绍js的基本数据类型"></a><strong>1.介绍js的基本数据类型</strong></h3><p><strong>Undefined</strong>、<strong>Null</strong>、<strong>Boolean</strong>、<strong>Number</strong>、<strong>String</strong></p>
<h3 id="2-js有哪些内置对象？"><a href="#2-js有哪些内置对象？" class="headerlink" title="2.js有哪些内置对象？"></a><strong>2.js有哪些内置对象？</strong></h3><p>数据封装类对象：Object、Array、Boolean、Number 和 String</p>
<p>其他对象：Function、Arguments、Math、Date、RegExp、Error</p>
<h3 id="5-DOM怎样添加、移除、移动、复制、创建和查找节点"><a href="#5-DOM怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="5.DOM怎样添加、移除、移动、复制、创建和查找节点"></a><strong>5.DOM怎样添加、移除、移动、复制、创建和查找节点</strong></h3><p>// 创建新节点</p>
<p>createDocumentFragment() //创建一个DOM片段</p>
<p>createElement() //创建一个具体的元素</p>
<p>createTextNode() //创建一个文本节点</p>
<p>// 添加、移除、替换、插入</p>
<p>appendChild()</p>
<p>removeChild()</p>
<p>replaceChild()</p>
<p>insertBefore() //在已有的子节点前插入一个新的子节点</p>
<p>// 查找</p>
<p>getElementsByTagName() //通过标签名称</p>
<p>getElementsByName()<br>//通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</p>
<p>getElementById() //通过元素Id，唯一性</p>
<h3 id="6-null和undefined的区别？"><a href="#6-null和undefined的区别？" class="headerlink" title="6.null和undefined的区别？"></a><strong>6.null和undefined的区别？</strong></h3><p>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。<br>undefined：</p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。<br>null：</p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<h3 id="8-JSON-的了解？"><a href="#8-JSON-的了解？" class="headerlink" title="8.JSON 的了解？"></a><strong>8.JSON 的了解？</strong></h3><p>JSON(JavaScript Object Notation)<br>是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单,<br>易于读写, 占用带宽小。</p>
<p>格式：采用键值对，例如：{‘age’:’12’, ‘name’:’back’}</p>
<h3 id="9-call-和-apply-的区别和作用？"><a href="#9-call-和-apply-的区别和作用？" class="headerlink" title="9.call() 和 apply() 的区别和作用？"></a><strong>9.call() 和 apply() 的区别和作用？</strong></h3><p>apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。</p>
<p>如：function.apply(this,[1,2,3]);</p>
<p>call()的第一个参数是上下文，后续是实例传入的参数序列。</p>
<p>如：function.call(this,1,2,3);</p>
<ol>
<li>说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）</li>
</ol>
<hr>
<ul>
<li><p>(Q1)<strong>行内元素</strong>：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。<br>块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。</p>
</li>
<li><p>(Q2)<strong>兼容性</strong>：display:inline-block;*display:inline;*zoom:1;</p>
</li>
</ul>
<h2 id="2-清除浮动有哪些方式？比较好的方式是哪一种？"><a href="#2-清除浮动有哪些方式？比较好的方式是哪一种？" class="headerlink" title="2.清除浮动有哪些方式？比较好的方式是哪一种？"></a>2.清除浮动有哪些方式？比较好的方式是哪一种？</h2><ul>
<li><p>（1）父级div定义height。</p>
</li>
<li><p>（2）结尾处加空div标签clear:both。</p>
</li>
<li><p>（3）父级div定义伪类:after和zoom。</p>
</li>
<li><p>（4）父级div定义overflow:hidden。</p>
</li>
<li><p>（5）父级div定义overflow:auto。</p>
</li>
<li><p>（6）父级div也浮动，需要定义宽度。</p>
</li>
<li><p>（7）父级div定义display:table。</p>
</li>
<li><p>（8）结尾处加br标签clear:both。</p>
</li>
</ul>
<h2 id="3-介绍一下你对浏览器内核的理解？"><a href="#3-介绍一下你对浏览器内核的理解？" class="headerlink" title="3.介绍一下你对浏览器内核的理解？"></a>3.介绍一下你对浏览器内核的理解？</h2><ul>
<li><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</p>
</li>
<li><p><strong>渲染引擎</strong>：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
</li>
<li><p><strong>JS引擎则</strong>：解析和执行javascript来实现网页的动态效果。</p>
</li>
<li><p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
</li>
</ul>
<h2 id="4-html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#4-html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="4.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>4.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<ul>
<li><p>(1)绘画 canvas;</p>
</li>
<li><p>(2)用于媒介回放的 video 和 audio 元素;</p>
</li>
<li><p>(3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</p>
</li>
<li><p>(4)sessionStorage 的数据在浏览器关闭后自动删除;</p>
</li>
<li><p>(5)语意化更好的内容元素，比如 article、footer、header、nav、section;</p>
</li>
<li><p>(6)表单控件，calendar、date、time、email、url、search;</p>
</li>
<li><p>(7)新的技术webworker, websocket, Geolocation;</p>
</li>
</ul>
</select>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/其它/">其它</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Struts与spring工作原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/13/Struts与spring工作原理/" class="article-date">
      <time datetime="2018-08-13T07:27:22.000Z" itemprop="datePublished">2018-08-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/13/Struts与spring工作原理/">Struts与Spring的工作原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Struts1工作机制：<br>(1)检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息;<br>(2)如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中;<br>(3)根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法;<br>(4)如果ActionForm的validate()方法返回或返回一个不包含ActionMessage的ActuibErrors对象, 就表示表单验证成功;<br>(5)ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的 Action实例不存在,就先创建这个实例,然后调用Action的execute()方法;<br>(6)Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给 ActionForward对象指向的JSP组件;<br>(7)ActionForward对象指向JSP组件生成动态网页,返回给客户;<br><img src="https://i.imgur.com/VZ4MCaJ.png" alt=""><br>springMvc的工作机制：</p>
<ol>
<li>第一步：用户向服务器发送请求，请求被Spring前端控制Servelt DispatcherServlet捕获；</li>
<li>第二步： DispatcherServlet对请求URL进行解析，得到请求资源标识符（URL），然后根据该URL调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</li>
<li>第三步： DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</li>
<li>第四步：提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： &gt;&gt; 1. HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 &gt;&gt; 2. 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 &gt;&gt; 3. 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期 &gt;&gt; 4. 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
<li>第五步： Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</li>
<li>第六步：根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</li>
<li>第七步：ViewResolver 结合Model和View，来渲染视图</li>
<li>第八步：将渲染结果返回给客户端。<br><img src="https://i.imgur.com/o4A6K4I.png" alt=""></li>
</ol>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/其它/">其它</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JavaSE" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/13/JavaSE/" class="article-date">
      <time datetime="2018-08-13T06:38:40.000Z" itemprop="datePublished">2018-08-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/13/JavaSE/">JavaSE</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>ArrayList arraylist=new ArrayList(21);扩容了几次？<br>ArrayList底层部分源码实现：<br>a、对于任何一个集合来说，集合中存放的是对象的引用，而不是对象本身。<br>b、ArrayList底层采用数组实现，当使用不带参数的构成方法生成ArrayList对象的时候，实际上会在底层生成一个长度为10的Object类型数组。简单来说ArrayList内部实现是数组。<br>c、如果增加的元素个数超过了10个，那么ArrayList底层会新生成一个数组，长度为原来数组的1.5倍，然后将原数组的内容复制到新数组中，并且后续增加的内容都会放到新数组当中，当新数组无法容纳增加的元素时，重复该过程。集合中不能放入原生数据类型，只能放置对象的引用，我们需要使用原生数据类型的包装类才能加入到集合当中。<br>2．Integer数据类型的比较？<br>Integer a=129;<br>Integer b=129;<br>System.out.println(a==b);//false<br>注：当Integer的值不在-128-127之间时，会自动创建一个新的对象；比较的是对象因此结果为false。<br>Integer c=12;<br>Integer d=12;<br>System.out.println(c==d);//true<br>注：当Integer的值在Byte类型的表示范围内时，则为值比较；因此为true<br>Integer e=129；<br>Int f=129；<br>System.out.println(a==b);//true<br>注：Integer类型数据的比较时，当数值在byte表示的范围之内即-128-127，则比较的是两个变量的内容，若超出Byte的范围则比较的是两个对象；<br>3．“==”与equals的区别：<br>==比较的是两个对象的地址码，equals比较的是两个对象的内容；前者的比较只要对象不是new初始化的即表示为true；<br>例：1.String m=”孤风”;<br>   String n=”孤风”;<br>   System.out.println(m==b);//true，因为当为n初始化时，会在堆内存中寻找是否存在”孤风”对象，如果存在则将内存地址给n变量；<br>  System.out.println(a.equals(b));//true，比较的是堆内存的对象内容；<br>例：2.String m=”孤风”;<br>   String n=new String(“孤风”);<br>   System.out.println(m==n);//false，因为n是由new创建并初始化的，所以结果为false；<br>   System.out.println(m.equals(n));//true，比较的是内容<br>注：String类型本身就是一个引用型数据类型，因此只有在new创建对象时，两个内容相同的对象的比较才会为false；而Integer的数值在-128到127之间时使用==表示的两个数值的比较，当表示范围超出范围时，表示的是两个不同地址码的对象比较，此时结果为false。</li>
</ol>
<p>4.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？  </p>
<pre><code>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
</code></pre><p>5.JDK和JRE的区别是什么？  </p>
<pre><code>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。
</code></pre><p>6.Java支持的数据类型有哪些？什么是自动拆装箱？</p>
<pre><code>Java语言支持的8中基本数据类型是：byte、short、int、long、float、double、boolean、char   
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。
</code></pre><p>7.接口和抽象类的区别是什么？</p>
<pre><code>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
抽象类可以在不提供接口方法实现的情况下实现接口。
Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。
</code></pre><p>8.什么是值传递和引用传递？  </p>
<pre><code>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。
对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。
</code></pre><p>9.进程和线程的区别是什么？  </p>
<pre><code>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
</code></pre><p>10.创建线程有几种不同的方式？你喜欢哪一种？为什么？  </p>
<pre><code>有三种方式可以用来创建线程：
继承Thread类
实现Runnable接口
应用程序可以使用Executor框架来创建线程池
实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。
</code></pre><p>11.概括的解释下线程的几种可用状态。  </p>
<pre><code>线程在执行过程中，可以处于下面几种状态：
就绪(Runnable):线程准备运行，不一定立马就能开始执行。
运行中(Running)：进程正在执行线程的代码。
等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。
睡眠中(Sleeping)：线程被强制睡眠。
I/O阻塞(Blocked on I/O)：等待I/O操作完成。
同步阻塞(Blocked on Synchronization)：等待获取锁。
死亡(Dead)：线程完成了执行。
</code></pre><p>12.什么是死锁(deadlock)？  </p>
<pre><code>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。
</code></pre><p>13.如何确保N个线程可以访问N个资源同时又不导致死锁？ </p>
<pre><code>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。
</code></pre><p>14.Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。  </p>
<pre><code>Java集合类里面最基本的接口有：
Collection：代表一组对象，每一个对象都是它的子元素。
Set：不包含重复元素的Collection。
List：有顺序的collection，并且可以包含重复元素。
Map：可以把键(key)映射到值(value)的对象，键不能重复。
</code></pre><p>15.为什么集合类没有实现Cloneable和Serializable接口？  </p>
<pre><code>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。
</code></pre><p>16.Iterator和ListIterator的区别是什么？   </p>
<pre><code>下面列出了他们的区别：
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。
</code></pre><p>17.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？  </p>
<pre><code>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。
</code></pre><p>18.Java中的HashMap的工作原理是什么？  </p>
<pre><code>Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。
HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。
</code></pre><p>19.HashMap和Hashtable有什么区别？  </p>
<pre><code>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
HashMap允许键和值是null，而Hashtable不允许键或者值是null。
Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。
一般认为Hashtable是一个遗留的类。
</code></pre><p>20.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？  </p>
<pre><code>下面列出了Array和ArrayList的不同点：
Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。
ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。
</code></pre><p>21.ArrayList和LinkedList有什么区别？  </p>
<pre><code>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。
相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。
也可以参考ArrayList vs. LinkedList。
</code></pre><p>22.什么是Java优先级队列(Priority Queue)？  </p>
<pre><code>PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。
</code></pre><p>23.如何权衡是使用无序的数组还是有序的数组？  </p>
<pre><code>有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。
</code></pre><p>24.Enumeration接口和Iterator接口的区别有哪些？  </p>
<pre><code>Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。
</code></pre><p>25.HashSet和TreeSet有什么区别？  </p>
<pre><code>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。
</code></pre><p>26.Java中垃圾回收有什么目的？什么时候进行垃圾回收？  </p>
<pre><code>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。
</code></pre><p>27.JVM的永久代中会发生垃圾回收么？  </p>
<pre><code>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区
</code></pre><p>28.Java中的两种异常类型是什么？他们有什么区别？  </p>
<pre><code>Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。这里有Java异常处理的一些小建议。
</code></pre><p>29.Java中Exception和Error有什么区别？  </p>
<pre><code>Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。
</code></pre><p>30.throw和throws有什么区别？  </p>
<pre><code>throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。
</code></pre><p>45.异常处理的时候，finally代码块的重要性是什么？(译者注：作者标题的序号弄错了)  </p>
<pre><code>无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。最后要说的是，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。
</code></pre><p>46.异常处理完成以后，Exception对象会发生什么变化？  </p>
<pre><code>Exception对象会在下一个垃圾回收过程中被回收掉。
</code></pre><p>47.Window和Frame有什么区别？  </p>
<pre><code>Frame类继承了Window类，它定义了一个可以有菜单栏的主应用窗口。
</code></pre><p>48.什么是JDBC？  </p>
<pre><code>JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。
</code></pre><p>49.Class.forName()方法有什么作用？  </p>
<pre><code>这个方法用来载入跟数据库建立连接的驱动。
</code></pre><p>50.PreparedStatement比Statement有什么优势？  </p>
<pre><code>PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。
</code></pre><p>51.什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？  </p>
<pre><code>CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：CallableStament.prepareCall();
</code></pre><p>52.数据库连接池是什么意思？  </p>
<pre><code>像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。
</code></pre><p>53.什么是分布式垃圾回收(DGC)？它是如何工作的？ </p>
<pre><code>DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。
</code></pre><p>54.什么是Servlet？  </p>
<pre><code>Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。
</code></pre><p>55.说一下Servlet的体系结构。  </p>
<pre><code>所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。
</code></pre><p>56..Applet和Servlet有什么区别？  </p>
<pre><code>Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。
</code></pre><p>57.解释下Servlet的生命周期。  </p>
<pre><code>对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet(译者注：这里应该是Servlet而不是server)的destroy()方法把Servlet删除掉。
</code></pre><p>58.doGet()方法和doPost()方法有什么区别？  </p>
<pre><code>doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。
doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。
</code></pre><p>59.如何知道是哪一个客户端的机器正在请求你的Servlet？  </p>
<pre><code>ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。
</code></pre><p>60.HTTP响应的结构是怎么样的？  </p>
<pre><code>HTTP响应由三个部分组成：
状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。
HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。
主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。
</code></pre><p>61.什么是cookie？session和cookie有什么区别？  </p>
<pre><code>cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：
无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。
在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。
</code></pre><p>62.浏览器和Servlet通信使用的是什么协议？  </p>
<pre><code>浏览器和Servlet通信使用的是HTTP协议。
</code></pre><p>63.什么是HTTP隧道？  </p>
<pre><code>HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。
</code></pre><p>64.sendRedirect()和forward()方法有什么区别？ </p>
<pre><code>sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。
</code></pre><p>65.什么是URL编码和URL解码？ </p>
<pre><code>URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。
</code></pre><p>66.什么是JSP页面？  </p>
<pre><code>JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。这里看下JSP的例子。
</code></pre><p>67.JSP请求是如何被处理的？ </p>
<pre><code>浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用    JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生    改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结    束，    servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。
</code></pre><p>68.JSP有什么优点？ </p>
<p>下面列出了使用JSP的优点：<br>    JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。<br>    JSP页面可以被预编译。<br>    JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结    合起来。<br>    开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。<br>    开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。</p>
<p>69.隐含对象是什么意思？有哪些隐含对象？  </p>
<pre><code>JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象：
application、page、request、response、session、exception、out、config、pageContext
</code></pre>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/其它/">其它</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-centos常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/06/centos常用命令/" class="article-date">
      <time datetime="2018-08-06T08:27:09.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/centos常用命令/">centos常用命令</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>reset –&gt;清空面板<br>ip addr –&gt;查询当前用户ip地址</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/编程/">编程</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-用户切换" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/06/用户切换/" class="article-date">
      <time datetime="2018-08-06T08:23:24.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/用户切换/">root用户与普通用户之间的切换</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <pre><code>普通用户切换到root用户：
    su-&gt;回车-&gt;输入root密码
    2）su -root-&gt;回车-&gt;输入root密码
root用户切换到普通用户： su &quot;普通用户名&quot;
</code></pre>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/编程/">编程</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 LoneWindFreedom
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="http://bestwing.me" target="_blank">Sw'blog</a> by Swing
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>